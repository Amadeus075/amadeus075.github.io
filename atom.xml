<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://amadeus075.github.io</id>
    <title>朝承恩的猫爬架</title>
    <updated>2021-09-27T14:26:12.600Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://amadeus075.github.io"/>
    <link rel="self" href="https://amadeus075.github.io/atom.xml"/>
    <subtitle>Purr for myself</subtitle>
    <logo>https://amadeus075.github.io/images/avatar.png</logo>
    <icon>https://amadeus075.github.io/favicon.ico</icon>
    <rights>All rights reserved 2021, 朝承恩的猫爬架</rights>
    <entry>
        <title type="html"><![CDATA[数据结构1 复习笔记]]></title>
        <id>https://amadeus075.github.io/post/shu-ju-jie-gou-1-fu-xi-bi-ji/</id>
        <link href="https://amadeus075.github.io/post/shu-ju-jie-gou-1-fu-xi-bi-ji/">
        </link>
        <updated>2021-09-27T13:10:57.000Z</updated>
        <content type="html"><![CDATA[<h1 id="食用说明">食用说明</h1>
<p>有些题目是很久以前写的，当时可能做错了，现在忘记是哪些做错了。</p>
<p>总之，复习时自己亲手写一遍，对照一下答案，比粗略的看一遍要好很多。</p>
<p>参考：https://www.cnblogs.com/aoru45/p/10429897.html</p>
<h1 id="一些好的练习题">一些好的练习题</h1>
<p>感觉看些填空选择就可以了</p>
<p>算法设计还是看课本的题目</p>
<p>在第五章应用题看见了考试原题</p>
<p><strong>①选择、填空、判断	有答案</strong></p>
<p>https://wenku.baidu.com/u/songguangya2?from=wenku		主页</p>
<p>已做：练习01、练习02(算法设计没看完)、练习03(算法设计没看)、习题04(无算法设计	选择填空难点较多)</p>
<p>难点：上下三角矩阵、字符串的字符(从1开始)、对称矩阵</p>
<p><strong>②选择、应用	有解析</strong></p>
<p>https://blog.csdn.net/m0_37243410/category_7048866.html		主页</p>
<p>选择、填空、简答已做		算法题没做</p>
<p>next数组：右移一位，左边补-1，然后全体+1</p>
<p><strong>③数据结构专项精讲课程讲义	有答案</strong></p>
<p>https://wenku.baidu.com/view/c48216b9b8f3f90f76c66137ee06eff9aef849bf.html</p>
<p><strong>④数据结构(C++版)课后答案_(王红梅)第2、3章	有解析</strong></p>
<p>https://wenku.baidu.com/view/0cabf3ea81c758f5f61f677a.html	主页</p>
<p>填空、选择已做</p>
<p><strong>⑤整版)非常实用的数据结构知识点总结</strong></p>
<p>https://wenku.baidu.com/view/0b36c2144128915f804d2b160b4e767f5acf80b2.html</p>
<h1 id="上海大学2015~2016数据结构一">上海大学2015~2016数据结构(一)</h1>
<h2 id="一-填空">一、填空</h2>
<p>1、在以HL为表头指针的带表头附加结点的单链表和循环单链表中，判断链表为空的条件分别为<strong>HL→next =NULL；和 HL=HL→next；</strong>。</p>
<p>2、调整得到的最小堆序列的最后一个元素为（<strong>78</strong>）</p>
<blockquote>
<p>参考：https://blog.csdn.net/hrn1216/article/details/51465270</p>
</blockquote>
<p>3、对于一个长读为n的顺序存储的线性表，在表头插入元素的时间复杂度为（<strong>O(n)</strong> ）。</p>
<blockquote>
<p>对于一个长度为n的顺序存储的线性表，在表头插入元素的时间复杂度为0(n)，在表尾插入元素的时间复杂度为0(1)。</p>
<p>顺序存储的线性表，是用数组实现的。在表尾插入元素，只要直接在表尾增加一个元素，并修改表的元素个数（加1）。所以其复杂度为0(1)。</p>
</blockquote>
<p>拓展：</p>
<blockquote>
<p>对于一个长度为n的单链存储的线性表，在表头插入元素的时间复杂度为______O(1）______，在表尾插入元素的时间复杂度为______O(n)______。</p>
<p>表头插入时间复杂度O(1），因为不需用移动元素，常数时间完成操作；表尾插入复杂度O(n)，因为每次操作都需用把指针先移动到表尾，需用n次移动。</p>
</blockquote>
<p>4、设栈S和队列Q的初始状态均为空，元素abcdefg依次进入栈S。若每个元素出栈后立即进入队列Q，且7个元素出队的顺序是bdcfeag，则栈S的容量至少是（<strong>3</strong>）</p>
<blockquote>
<p>栈后入先出的特点。队列先入先出，即队列也是bdcfeag</p>
<p>开始a先入栈，然后b入栈，然后b出栈，队列b 然后c,d依次入栈，然后d,c依次出栈，队列bcd 然后e,f依次入栈，然后f e 出栈队列bdcfe</p>
<p>a出栈，g进栈g出栈；</p>
<p>栈最多时为3 即 acd 、aef时栈深度为3</p>
</blockquote>
<p>5、一个栈的入栈序列为1,2,3,...,n ，其出栈序列是 p1, p2, p3, … pn 。若p2 = 3，则 p3 可能取值的个数是（<strong>n-1</strong>）</p>
<figure data-type="image" tabindex="1"><a href="https://imgtu.com/i/4R3VPg"><img src="https://z3.ax1x.com/2021/09/27/4R3VPg.png" alt="4R3VPg.png" loading="lazy"></a></figure>
<p>6、设以数组Q.elems[maxSize]存储循环队列的元素，同时以Q.rear和Q.length分别指示循环队列中的队尾位置和队列中所含元素的个数</p>
<pre><code class="language-c++">Q.length==0		//队空的条件
Q.length==maxSize	//队满的条件
//入队
Q.rear=(Q.rear+1)%maxSize;// 移动指针
Q.elems[Q.rear]=x;// 入队元素
Q.length++;// 队列长度加1
</code></pre>
<blockquote>
<p>参考：https://blog.csdn.net/cnds123321/article/details/106740109</p>
</blockquote>
<p>7、一维数组的逻辑结构是(线性结构)，存储结构是(顺序结构)；对于二维或多维数组，分(以行为主序)和(以列为主序)两种不同存储方式。</p>
<blockquote>
<p>一维数组是 顺序存储结构 二维数组或多维数组 行优先或者列优先 逻辑结构 线性结构</p>
</blockquote>
<p>8、一个右子树为空的二叉树在后序线索化后，其空指针域的个数为：<strong>2</strong></p>
<p>拓展：</p>
<blockquote>
<p>一棵左子树为空的二叉树在先序线索化后，其中空的链域的个数是___D___。</p>
<p>A．不确定<br>
B．0<br>
C．1<br>
D．2</p>
<p>解释：</p>
<p>左子树为空的二叉树的根结点的左线索为空(无前驱)，先序序列的最后结点的右线索为空(无后继)，共2个空链域。</p>
</blockquote>
<p>9、设n 为哈夫曼树的叶子结点数目，则该哈夫曼树共有（<strong>2n-1</strong>）个结点。</p>
<blockquote>
<p>首先，哈夫曼树是一个二叉树；第二点，哈弗曼树的度只有两种情况，一是只有两个度的结点，二是没有度的结点，即叶子结点。设两个度的节点数为n2, 已知叶子结点为n，总节点数减1等于分支数，可知n2+n-1=2*n2</p>
</blockquote>
<p>————————————————————————————————————————————————</p>
<blockquote>
<p>无论哈夫曼树是几叉，其特点是一致的（假设为m叉），即树中只存在度为0的结点（即叶结点）和度为m的结点。不妨设度为0的结点个数为x，度为m的结点个数为y，则存在一个等式x+y=my+1，即x=(m-1)y+1，x+y是树的总结点个数。</p>
<p>就这道题来说，假设哈夫曼树是二叉的话，则度为0的结点个数为N，度为2的结点个数为N-1，则结点总数为2N-1。</p>
</blockquote>
<h2 id="二-单选题">二、单选题</h2>
<p>1、广义表A=(a),则表尾为	(<strong>C	空表</strong>)</p>
<p>2、若某线性表最常用的操作是存取任一指定序号的元素和在最后进行插入和删除运算，则利用( <strong>A	顺序表</strong>)存储方式最节省时间</p>
<blockquote>
<p>“存取任一指定序号”最好的方法是实现“随机存取”，则可采用顺序表。并且，因为插入和删除操作都是在最后进行的，所以无需大量移动数据元素，选项A是最合适的。</p>
</blockquote>
<p>3、假设栈初始为空，将中缀表达式<strong>a/b+(c*d-e*f)/g</strong>转化为等价的狗追表达式的过程中，当扫描到f时，栈中的元素依次是（<strong>B	+（-</strong>*）</p>
<blockquote>
<p>参考：https://blog.csdn.net/qq_22073849/article/details/78416135</p>
</blockquote>
<p>4、已知循环队列存储在一维数组A[0…n-1]，且队列非空时，front和rear分别指向队头元素和队尾元素。若初始时队列为空，且要求第一个进入队列的元素存储在A[0]处，则初始时front和rear的值分别是（<strong>B. 0，n-1</strong> ）</p>
<blockquote>
<p>参考：https://blog.csdn.net/qq_22073849/article/details/78362502</p>
<p>https://www.nowcoder.com/questionTerminal/1d83ef24b318444e81dd426c657bd61c</p>
</blockquote>
<blockquote>
<p>插入时，队头指针不变，队尾指针后移一位。该题约定队列非空时 front  和 rear 分别指向队头和队尾元素，即插入第一个元素在下标为0的位置后，队头队尾指针皆指向A[0]，此时可以反推出插入前，队头指针仍旧指向下标0，而队尾指针应指向前一位，也就是下标n-1的位置。注意，这道题的约定与大多数题约定队列为空时front=rear=0是不一样的约定，都是根据题意解题。</p>
</blockquote>
<p>5、<code>设有一个10阶的下三角矩阵A（包括对角线），按照从上到下、从左到右的顺序存储到连续的55个存储单元中，每个数组元素占1个字节的存储空间，则A[5][4]地址与A[0][0]的地址之差为（ B 19 ）。</code></p>
<figure data-type="image" tabindex="2"><a href="https://imgtu.com/i/4R3e2j"><img src="https://z3.ax1x.com/2021/09/27/4R3e2j.png" alt="4R3e2j.png" loading="lazy"></a></figure>
<p>6、广义表A=(（x, (a ,b)), (x,(a,b),y)), 则运算Head(Head(Tail(A)))结果为(  <strong>A x</strong> )</p>
<blockquote>
<p>题目中给出的：</p>
<p>A=(x, (a ,b) ), (x, (a,b)  ,y) )  少了一个括号配对，应该为：<strong>A=( （x, (a,b)）,(x, (a,b), y)  )</strong></p>
<p>Head( Head( Tail(A) ) )  ) 多了一个括号，应该改为：<strong>Head( Head( Tail(A) ) )</strong></p>
<p>由内到外依次运算：Head广义表的第一个元素，Tail取广义表除了第一个元素外的其他元素</p>
<ol>
<li>Tail(A)=（x, (a,b), y）</li>
<li>Head(Tail(A))=(x)</li>
<li>Head(Head(Tail(A)))=(x)</li>
</ol>
</blockquote>
<p>7、函数substr(&quot;DATASTURCTURE&quot;,5,9)的返回值为( <strong>A STRURCTURE</strong> )</p>
<blockquote>
<p>substr(&quot;DATASTURCTURE&quot;,5,9)<br>
这个函数的意思是从字符串“DATASTURCTURE”的第五个字符S开始，截取后面的9个字符。<br>
所以为：<br>
STRURCTURE</p>
</blockquote>
<p>8、C 	26</p>
<p>9、一棵完全二叉树上有1001个结点，其中叶子结点的个数是（<strong>A 501</strong>）</p>
<blockquote>
<figure data-type="image" tabindex="3"><a href="https://imgtu.com/i/4R3ZGQ"><img src="https://z3.ax1x.com/2021/09/27/4R3ZGQ.png" alt="4R3ZGQ.png" loading="lazy"></a></figure>
</blockquote>
<p>10、设n、m为一棵二叉树上的两个结点，在中序遍历时，n在m前的条件是(<strong>C．n在m左方</strong> )。</p>
<blockquote>
<p>中序遍历时，先访问左子树，再访问根结点。n在m前，则n必须在m的左子树中。因此本题答案为C。</p>
</blockquote>
<blockquote>
<p>中序遍历为左根右，所以n一定要在m左边</p>
</blockquote>
<blockquote>
<p>参考：https://blog.csdn.net/qq_43839907/article/details/103359858</p>
</blockquote>
<h2 id="三-是非题">三、是非题</h2>
<p>1、线性表采用链表存储时，查找第i个元素的时间与i的值无关	(<strong>×</strong>)</p>
<blockquote>
<p>线性链表的存储是非顺序存储的，访问第i个元素是需要从第一个元素开始一个一个的来寻找，所以跟i值成正比，线性表在顺序存储时，是顺序存储的，访问第i个元素是可以直接访问到，时间复杂度为o(1)，与i无关</p>
</blockquote>
<p>2、非空的双向循环链表中任何结点的前驱指针均不为空。（<strong>√</strong> ）</p>
<blockquote>
<p>是正确的。 只要是循环链表，任一一个节点的前驱指针和后继指针都不会为空。 双向循环链表是循环链表的一种，所以也适用于这个规律。<br>
原因如下：<br>
1 对于单向链表，是从第一个节点开始，到最后一个节点结束，其指向为<br>
P1-&gt;P2-&gt;P3-&gt;...-&gt;Pn<br>
第一个节点P1的前驱指针和最后一个节点Pn的后继指针为空。<br>
2 对于循环链表， 会将最后一个节点指向第一个节点，构成循环：<br>
P1-&gt;P2-&gt;P3-&gt;...-&gt;Pn-&gt;P1<br>
而双向循环链表则是每个节点两个指针，分别指向上一个和下一个：<br>
P1&lt;-&gt;P2&lt;-&gt;P3&lt;-&gt;...&lt;-&gt;Pn&lt;-&gt;P1<br>
从这个结构可以看出， 每一个节点的前驱和后继都不可能为空， 当只有一个节点的时候，前驱和后继都是自身。</p>
</blockquote>
<p>3、某队列允许在其两端进行入队操作，但仅允许在一端进行出队操作，则不可能得到的顺序是dbcae( √ )</p>
<blockquote>
<p>正确答案是 C</p>
<p>本题的队列实际上是一个输出受限的双端队列。A操作：a左入（或右入）、b左入、c右入、d右入、e右入。B操作：a左入（或右入）、b左入、c右入、d左入、e右入。D操作：a左入（或右入）、b左入、c左入、d右入、e左入。C操作：a左入（或右入）、b右入、因d未出，此时只能进队，c怎么进都不可能在b和a之间。</p>
<p>【另解】初始时队列为空，第1个元素a左入（或右入），而第2个元素b无论是左入还是右入都必与a相邻，而选项D中a与b不相邻，不合题意。</p>
</blockquote>
<blockquote>
<p>[解析] 考查受限的双端队列的出队序列。<br>
A．可由左入，左入，右入，右入，右入得到；<br>
B．可由左入，左入，右入，左入，右入得到；<br>
D．可由左入，左入，左入，右入，左入得到；<br>
所以不可能得到C。</p>
</blockquote>
<p>4、用不带头结点的单链表存储队列时，队头指针指向队头结点，队尾指针指向队尾结点，则在进行出队操作时只需要修改队头指针(× )。</p>
<blockquote>
<p>如果当前队列中仅有一个元素，则删除它时队头、队尾指针都需要修改。</p>
</blockquote>
<p>5、稀疏矩阵压缩存储后，必然会失去随机存取功能（√）</p>
<blockquote>
<p>稀疏矩阵压缩存储后，必会失去随机存取功能。稀疏矩阵在采用压缩存储后将会失去随机存储的功能。因为在这种矩阵中，非零元素的分布是没有规律的，为了压缩存储，就将每一个非零元素的值和它所在的行、列号做为一个结点存放在一起，这样的结点组成的线性表中叫三元组表，它已不是简单的向量，所以无法用下标直接存取矩阵中的元素。</p>
</blockquote>
<blockquote>
<p>稀疏矩阵用三元组存储，已经不能用简单的下标来实现访问，所以已经失去了随机访问的功能</p>
</blockquote>
<p>6、广义表的组成元素可以是不同形式的元素（√）</p>
<p>7、一个广义表的表头为空表,则此广义表亦为空表（×）</p>
<blockquote>
<p>举一个简单的反例就可说明为什么了,例如广义表L = { { },1,2 },该广义表的长度为3,深度为2,表头head(L) = { },tail(L) = {1,2},可以看出表头为{ },它是一个空表,但表L并不是空表的呀.</p>
</blockquote>
<p>8、对一棵二叉树进行层次遍历时,应借助于一个队列(√)</p>
<blockquote>
<p>应该借助于队列，二叉树的先序，后序，中序的非递归遍历才需要栈</p>
</blockquote>
<blockquote>
<p>由层次遍历的定义可知，在进行层次遍历时，对一层的结点访问完后，在按照他们的访问次序依次对各个节点的左右孩子顺序访问，这样一层一层的进行，先遇到的结点先访问，这与队列的操作原则比较吻合，因此在进行层次遍历时，可设置一个队列结构，遍历从二叉树的根节点开始，首先将根节点指针入队列，依次执行下面操作：</p>
<p>1）队列不空，出队列，去队头元素</p>
<p>2）访问该元素所指结点</p>
<p>3）若该元素所指结点的左右孩子结点非空，则该元素所指结点的左孩子指针和右孩子指针顺序入队。</p>
</blockquote>
<p>9、二叉树中序线索化后，不存在空指针域（×）</p>
<blockquote>
<p>非空二叉树中序遍历第一个结点无前驱，最后一个结点无后继，这两个结点的前驱线索和后继线索为空指针。</p>
</blockquote>
<p>10、完全二叉树中，若一个结点没有左孩子，则它必是树叶（√）</p>
<blockquote>
<p>完全二叉树如果没有左结点，则一定没有右结点，即没有左孩子，它就一定是树叶。</p>
</blockquote>
<blockquote>
<p>参考：https://blog.csdn.net/weixin_46678290/article/details/105408072</p>
</blockquote>
<h2 id="四-应用题">四、应用题</h2>
<p>1、KMP算法，计算失效函数值，填写KMP算法每一轮的匹配过程</p>
<blockquote>
<p>参考：https://blog.csdn.net/lemon_sun/article/details/37655509</p>
</blockquote>
<p>2、已知频率，构造并画出哈夫曼树，求哈夫曼编码</p>
<h2 id="五-问答题">五、问答题</h2>
<p>1、已知一棵二叉树的层次序列、中序序列，画出该二叉树，写出后序序列，求高度</p>
<blockquote>
<p>参考：https://bbs.csdn.net/topics/70107860</p>
</blockquote>
<p>2、利用栈S1和S2模拟一个队列，完成入队、出队、判空操作</p>
<blockquote>
<p>参考：https://blog.csdn.net/fan9511/article/details/38015891</p>
<p>https://blog.csdn.net/weixin_44279771/article/details/107860898</p>
</blockquote>
<h2 id="六-算法填空题">六、算法填空题</h2>
<p>1、将不带头结点的非空单链表A分解成两个单链表A和B</p>
<blockquote>
<p>参考：https://blog.csdn.net/qq_43648337/article/details/107494392</p>
</blockquote>
<p>2、在二叉树的二叉链表类模板中，实现非递归中序遍历二叉树</p>
<blockquote>
<p>参考：http://c.biancheng.net/view/3389.html</p>
<p>https://blog.csdn.net/qq_33060405/article/details/78505347</p>
</blockquote>
<h2 id="七-算法设计题">七、算法设计题</h2>
<p>1、在单链表类中增加一个用于判断带头结点的单链表中数据元素是否是递增的成员函数</p>
<h1 id="上海大学2014~2015数据结构一">上海大学2014~2015数据结构(一)</h1>
<h2 id="一-填空题">一、填空题</h2>
<p>1、带头结点的循环链表 L 中只有一个元素结点的条件是（<strong>head-&gt;next-&gt;next=head</strong>） 。</p>
<p>拓展：</p>
<blockquote>
<figure data-type="image" tabindex="4"><a href="https://imgtu.com/i/4R3AIS"><img src="https://z3.ax1x.com/2021/09/27/4R3AIS.png" alt="4R3AIS.png" loading="lazy"></a></figure>
</blockquote>
<p>2、在顺序表中访问任意一结点的时间复杂度均为（<strong>O（1）</strong>），因此，顺序表也称为（<strong>随机存取</strong>）的数据结构</p>
<p>3、设栈S和队列Q的初始状态为空。元素a、b、c、d、e、f依次通过栈S，并且一个元素出栈后即进入队列Q，若出队的顺序为b、d、c、f、e、a，则栈S的容量至少应该为（<strong>3</strong>）</p>
<blockquote>
<p>[分析] 由于队列是先进先出线性表，队列Q的出队顺序为b、d、c、f、e、a，则入队顺序必定也是b、d、c、f、e、a，这一顺序就是栈S的出栈顺序。又由于入栈顺序为a、b、c、d、e、f，因此入栈和出栈顺序是：a、b入栈，b出栈，c、d入栈，d、c出栈、e、f入栈，f、e、a出栈，因此栈中驻留元素最多是3个，因此栈S的容量至少应该为3。</p>
</blockquote>
<p>5、假设一棵二叉树的结点个数为1638，则它的最小高度是（<strong>11</strong> ）</p>
<blockquote>
<p>高度最少的时候，就是除了叶子结点外，其他的每层都是满节点，即满二叉树。满二叉数节点和高度的关系有：节点数=2的高度次方-1，由此可以推算出，当节点数是1638的时候，该二叉树的最小高度是11层</p>
</blockquote>
<p>6、在一个最小堆中，所有结点中的最大值一定在（<strong>叶子</strong>）结点中</p>
<p>拓展：</p>
<blockquote>
<p><img src="%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84(1)%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0.assets/image-20210310155312804.png" alt="image-20210310155312804" loading="lazy"><a href="https://imgtu.com/i/4R3ka8"><img src="https://z3.ax1x.com/2021/09/27/4R3ka8.png" alt="4R3ka8.png" loading="lazy"></a></p>
</blockquote>
<p>7、广义表运算式 Tail(((a,b),(c,d)))的操作结果是（  <strong>((c,d))</strong>  ）</p>
<blockquote>
<p>表尾是指除了表头以外所有原子和子表组成的新表。</p>
<p>原表：((a,b),(c,d))</p>
<p>表头：(a,b)</p>
<p>表尾：((c,d))  // 表尾是新表所以多一层括号</p>
</blockquote>
<p>8、已知串S=‘aaab’,其Next数组值为（ <strong>0 1 2 3</strong> ）</p>
<blockquote>
<p>序号：1 2 3 4<br>
数组：a a a b<br>
next： 0 1 2 3</p>
<p>注意上边序号、数组和next的对应关系</p>
<p>求next值的过程：<br>
前两位：next数组值前两位一定为01，即aaab中的前两位aa对应01，如上表中next第1，2位为0和1.其实这就可以选出答案了.</p>
<p>第三位：3a前面是2a（2a表示序号为2的a），2a的next数组值为1，找到序号为1的字符, 即1a,将2a和1a相比，两者相同，都是a，则3a的next值为2a的next值加1，即2；</p>
<p>第四位：4b前3a的next为2，找到序号为2的字符, 即2a, 将3a与2a相比，二者相同，则其next值为3a的next加1，为3.<br>
结果为0123</p>
</blockquote>
<blockquote>
<p>KMP算法的关键是计算一个next数组，也叫做失效函数</p>
</blockquote>
<p>9、求哈夫曼树的带权路径长度</p>
<blockquote>
<p>参考：</p>
<p>https://blog.csdn.net/qq_33369979/article/details/100060262</p>
<p>https://blog.csdn.net/xueba8/article/details/78477892</p>
</blockquote>
<p>10、数据结构主要研讨数据的<strong>逻辑结构</strong>和<strong>物理结构</strong>，以及它们之间的<strong>相互关系</strong>，并对这种结构定义相应<strong>操作/运算</strong>，设计出相应的<strong>算法</strong>。</p>
<h2 id="二-选择题">二、选择题</h2>
<p>1、某线性表中最常用的操作是在最后一个元素之后插入一个元素和删除第一个元素，则采用（<strong>A</strong> <strong>仅有尾指针的单循环链表</strong>）存储方式最节省运算时间。</p>
<blockquote>
<p>仅有尾指针的单循环链表，可以非常方便地找到尾结点，尾结点后面的第一个结点往往是头结点，头结点的下一个结点就是第线性表的第一个结点。对最后一个元素和第一个元素操作对带尾指针的单循环链表是非常方便的。</p>
</blockquote>
<p>2、在双向链表中，在p结点之后插入结点q的操作是( <strong>B	q-＞next=p-＞next；p-＞next-＞prior=q；p-＞next=q；q-＞prior=p；</strong> )。</p>
<blockquote>
<p>[解析] 在链表中，对指针的修改必须保持线性表的逻辑关系，否则，将违背线性表的逻辑特征。<br>
本题主要考查双向链表的插入算法中的指针的变化过程。虽然4个选项中的语句相同，但顺序不同，根据双向链表的结构特点可知选项B的操作顺序是正确的，其他3个选项的指针修改顺序不能完成在<em>p结点之后插入结点</em>q的操作。</p>
</blockquote>
<p>3、为了增加内存空间的利用率和减少溢出的可能性，由两个栈共享一片连续的内存空间时，应将两个栈的栈底分别设在这片内存空间的两端。如此只有当( <strong>C 两个栈的栈顶在栈空间的某一位置相遇</strong> )时，才产生溢出。</p>
<blockquote>
<p>[解析] 在一个程序中需要同时使用具有相同成分类型的两个栈时，为避免造成存储空间的浪费，应采用双进栈操作。为两个栈共同开辟一个连续的存储空间，一个栈的栈底为该空间的始端，另一个栈的栈底为该存储空间的末端。当元素进栈时都从此存储空间的两端向中间“延伸”。只有当两个栈的栈顶在该存储空间的某处相遇时，才会发生上溢。</p>
</blockquote>
<p>4、用不带头结点的单链表存储队列时，其队头指针指向队头结点，其队尾指针指向队尾结点，则在进行删除操作时(  <strong>D</strong> <strong>队头、队尾指针都可能要修改</strong> )。</p>
<blockquote>
<p>如果当前队列中仅有一个元素，则删除它时队头、队尾指针都需要修改。</p>
<p>因为当队列中只有一个元素时，删除此元素后要将队列置空，此时要修改队尾指针，使尾指针与头指针相等（即Q.rear = Q.front）</p>
</blockquote>
<p>5、稀疏矩阵采用压缩存储的目的主要是为了 （<strong>C 节省存储空间</strong>）。</p>
<blockquote>
<p>对稀疏矩阵，目前还没有一个明确的定义，但是一般认为，稀疏矩阵是非零元素较零元素少，且分布没有一定规律的矩阵。在矩阵运算中和矩阵输入输出中，最方便的存储方式就是二维数组，对矩阵进行压缩不能简化矩阵运算，对输入输出也不能提供便利，而降低运算的时间复杂度主要与算法有关，一般对矩阵压缩后其运算的复杂度会增加。所以答案是节省存储空间。</p>
</blockquote>
<p>6、设有一个10阶的对称矩阵A，采用压缩存储方式，以行序为主存储，a1,1为第一元素，其存储地址为1，每个元素占一个地址空间，则a8,5的地址是（<strong>B  33</strong>）。</p>
<blockquote>
<p>[解析] 这里数组下标从1开始，只存储其下三角形元素，在a8,5的前面有7行，第1行有1个元素，第2行有2个元素，…，第7行有7个元素，这7行共有(1+7)×7/2=28个元素，在第8行中，a8,5的前面有4个元素，所以，a8,5前有28+4=32个元素，其地址为33。</p>
</blockquote>
<p>7、数据在计算机存储器内表示时，物理地址与逻辑地址不相同的，称之为（<strong>C	链式存储结构</strong>）</p>
<p>8、若一棵二叉树具有10个度为2的结点，5个度为1的结点，则二叉树的结点个数是(<strong>C 26</strong> )。</p>
<blockquote>
<p>拓展：</p>
<p>若一棵二叉树具有10个度为2的结点， 5个度为1的结点，则度为0的结点 （即叶子结点）个数是（39） 。</p>
<p>n=n0+n1+n2 	n=1+n1+2*n2 （n为结点总数，n0为度为0的结点数，n1为度为1的结点数，n2为度为2的结点数） 可以推出 n0=n2+1 因此，度为0的结点个数=10+1=11</p>
</blockquote>
<p>9、下列有关二叉树的说法中，正确的是( <strong>B．一棵二叉树的度可以小于2</strong> )。</p>
<blockquote>
<p>[解析]二叉树的定义为：二叉树是结点的有限集合，这个有限集合或者为空集，或者由一个根结点及两棵不相交的分别称做这个根的左子树和右子树的二叉树所构成，这里的左子树和右子树也符合二叉树的定义。由二叉树定义可得到这些信息：二叉树可以是空集，当二叉树为空集时，度为0；每个结点有两棵可以是空集的子树，当一棵子树为空，另一棵子树来为空时，该结点的度为1，都不为空时，度为2。由此可判断A、C、D是错误的，二叉树的度可以为0、1，结点的度也可以是0、1；选项B是正确的。</p>
</blockquote>
<p>10、一棵非空的二叉树的先序遍历序列与后序遍历序列正好相反，则该二叉树一定满足（<strong>C	只有一个叶子结点</strong>）</p>
<blockquote>
<p>之所以不能选AB，是因为题目中只交代了非空，</p>
<p>而如果该二叉树只有根节点，即满足了AB条件，</p>
<p>而显然此状态下，三种遍历顺序的结果都相同。</p>
<p>因此我们只能选择C</p>
<p>先序：根-&gt;左-&gt;右</p>
<p>后序：左-&gt;右-&gt;根</p>
<p>只有两个节点是，可以省略为：</p>
<p>先序：根-&gt;孩子</p>
<p>后序：孩子-&gt;根</p>
<p>因此选C</p>
</blockquote>
<h2 id="三-是非题-2">三、是非题</h2>
<p>1、线性表采用顺序存储结构时，可以进行较快的插入和删除。		（×）</p>
<blockquote>
<p>[解析] 在顺序表上做插入删除，将引起大量元素的移动。散列表也不便于删除，只有链接表既便于插入删除(因为只需要修改指针，不需要移动元素)，又能(通过指针域)反应元素之间的逻辑关系。</p>
</blockquote>
<p>2、单链表中取第i个元素的时间与i成正比。（√)</p>
<p>3、循环顺序队列不存在上溢问题	（×）</p>
<blockquote>
<p>​		<strong>① &quot;下溢&quot;现象</strong><br>
当队列为空时，做出队运算产生的溢出现象。“下溢”是正常现象，常用作程序控制转移的条件。<br>
　　<strong>② &quot;真上溢&quot;现象</strong><br>
当队列满时，做进栈运算产生空间溢出的现象。“真上溢”是一种出错状态，应设法避免。<br>
　　<strong>③ &quot;假上溢&quot;现象</strong><br>
　　由于入队和出队操作中，头尾指针只增加不减小，致使被删元素的空间永远无法重新利用。当队列中实际的元素个数远远小于向量空间的规模时，也可能由于尾指针已超越向量空间的上界而不能做入队操作。该现象称为&quot;假上溢&quot;现象。</p>
</blockquote>
<blockquote>
<p>参考：http://blog.sina.com.cn/s/blog_5b9734c501015wjp.html</p>
</blockquote>
<p>4、若输入序列为abcd，则通过一个栈可以输出cdab	（×）</p>
<p>5、若一个广义表的表头为空表,则此广义表一定不为空表	（×）	类似的题目</p>
<p>举一个简单的反例就可说明为什么了,例如广义表L = { { },1,2 },该广义表的长度为3,深度为2,表头head(L) = { },tail(L) = {1,2},可以看出表头为{ },它是一个空表,但表L并不是空表的呀.</p>
<p>6、一个稀疏矩阵 A m n 采用三元组形式表示，若把三元组中有关行下标与列下标的值互换，并把m和n的值互换，就完成了A mn 的转置运算。（×）</p>
<blockquote>
<p>行列互换，再按行排序</p>
</blockquote>
<p>7、数据元素是数据的最小单位。	（×）</p>
<blockquote>
<p>数据元素是数据的基本单位, 数据项是不可分割的最小单位<br>
数据项是构成数据元素的最小单位</p>
</blockquote>
<p>8、二叉树的存储结构必须采用二叉链表结构	（×）</p>
<p>9、二叉树的第i层上一定有 2^(i-1)个结点。	（×）</p>
<blockquote>
<p>二叉树的第i层上最多有 2^(i-1)个结点。</p>
</blockquote>
<p>10、健壮的算法不会因非法的输入数据而出现莫名其妙的状态。	（√）</p>
<blockquote>
<p>健壮的算法，当有非法输入的时候，程序会自动给出错误提示而不会出现莫名奇怪的状态</p>
</blockquote>
<h2 id="四-设计题">四、设计题</h2>
<p>1、</p>
<figure data-type="image" tabindex="5"><a href="https://imgtu.com/i/4R3mxs"><img src="https://z3.ax1x.com/2021/09/27/4R3mxs.png" alt="4R3mxs.png" loading="lazy"></a></figure>
<blockquote>
<p>参考：https://wenku.baidu.com/view/0cabf3ea81c758f5f61f677a.html</p>
</blockquote>
<p>2、将稀疏矩阵的三元组顺序表修改为 带行指针数组的二元组顺序表</p>
<h2 id="五-问答题-2">五、问答题</h2>
<p>1、已知二叉树的先序、中序序列，求其高度、叶子结点数，画出该二叉树和后续线索</p>
<p>2、已知广义表，求其长度、深度、表头、表尾，画出其链式存储结构的示意图</p>
<h2 id="六-算法填空题-2">六、算法填空题</h2>
<p>1、单链表的原地逆转</p>
<blockquote>
<p>参考：https://www.cnblogs.com/young-for-you/p/7286905.html</p>
<p>http://blog.sina.com.cn/s/blog_68c53ea90101bcl5.html</p>
</blockquote>
<p>2、在中序线索二叉树中插入左孩子</p>
<blockquote>
<p>参考：https://wenku.baidu.com/view/0b085eec58eef8c75fbfc77da26925c52dc5910d.html</p>
</blockquote>
<h2 id="七-算法设计题-2">七、算法设计题</h2>
<p>1、用不带头结点的单循环链表表示队列，完成入队、出队函数</p>
<blockquote>
<p>参考：https://blog.csdn.net/weixin_44790790/article/details/110297513</p>
</blockquote>
<h1 id="网课笔记">网课笔记</h1>
<h2 id="第一章">第一章</h2>
<p>只需挑循环中的一个基本操作分析它的执行次数与n的关系即可</p>
<p>如果有多层嵌套循环，只需关注最深层循环循环了几次</p>
<h2 id="第二章线性表">第二章	线性表</h2>
<p>具有相同数据类型的有限序列，每个数据元素所占空间一样大</p>
<p>表长n=0时，线性表是一个空表</p>
<p>ai是线性表中的第i个元素，i是位序	位序从1开始，数组下标从0开始	a1是表头元素，an是表尾元素</p>
<p>线性表分为顺序表（顺序存储）和链表（链式存储）</p>
<p>求一个数据元素的大小：sizeof(ElemType)</p>
<h3 id="顺序表的实现静态分配">顺序表的实现——静态分配</h3>
<p>静态数组：定义的最大长度不可改变（存储空间是静态的）</p>
<p>大小为：MaxSize * sizeof(ElemType)</p>
<h3 id="顺序表的实现动态分配">顺序表的实现——动态分配</h3>
<p>malloc函数返回一个指针，需要强制转型为你定义的数据元素类型指针</p>
<pre><code class="language-c++">ElemType *data;	//指示动态分配数组的指针
L.data = (ElemType *) malloc(sizeof(ElemType) * InitSize);	//申请一片连续的存储空间
</code></pre>
<p>顺序表的特点：</p>
<p>①随机访问</p>
<p>②存储密度高</p>
<p>③拓展容量不方便</p>
<p>④插入删除不方便，要移动大量元素</p>
<p>插入操作时间复杂度	最好情况：O(1)	最坏情况：O(n)	平均情况O(n)</p>
<p>删除操作时间复杂度	最好情况：O(1)	最坏情况：O(n)	平均情况O(n)</p>
<p>按位查找：获取第i个位置的元素的值	时间复杂度O(1)</p>
<p>按值查找：查找具有给定关键字值的元素	时间复杂度O(n)</p>
<p>注意：手写代码主要考察是否理解算法思想，不会严格要求代码完全可以运行</p>
<h4 id="单链表">单链表</h4>
<p>每个结点除了存放数据元素外，还要存储指向下一个结点的指针</p>
<pre><code class="language-c++">struct LNode * p (struct LNode *) malloc(sizeof(struct LNode));	//增加一个新结点
</code></pre>
<p>typedef  数据类型 别名;</p>
<p>用途：数据类型重命名</p>
<p>所以可以简洁代码：</p>
<pre><code class="language-c++">typedef struct LNode Lnode;
LNode * p = (LNode *) malloc(sizeof(LNode));	//增加一个新结点
</code></pre>
<p>会采用重命名的方式来定义类型</p>
<figure data-type="image" tabindex="6"><a href="https://imgtu.com/i/4R31aT"><img src="https://z3.ax1x.com/2021/09/27/4R31aT.png" alt="4R31aT.png" loading="lazy"></a></figure>
<figure data-type="image" tabindex="7"><a href="https://imgtu.com/i/4R3lZV"><img src="https://z3.ax1x.com/2021/09/27/4R3lZV.png" alt="4R3lZV.png" loading="lazy"></a></figure>
<p>不带头结点：头指针会存放实际数据	写代码会麻烦一点</p>
<p>带头结点的单链表：头结点不存储数据	方便一些</p>
<p>按位序插入（带头结点）：可以把头结点看作第0个结点</p>
<p>按位序插入（不带头结点）：i=1时要进行特殊处理</p>
<p>考试中两种情况都有可能考察，注意审题</p>
<p>按位序删除：只考虑带头结点</p>
<p>单链表的查找（只考虑带头结点）	这个函数可以用在别的函数内，找到指定结点</p>
<p>​	按位查找：返回第i个元素	O(n)</p>
<p>​	按值查找：找到数据域==e的结点	O(n)</p>
<p>单链表的建立：核心就是初始化操作、指定结点的后插操作</p>
<p>​	尾插法	设置一个表尾指针</p>
<p>​	头插法	可以用作链表的逆置	设置表头指针</p>
<p>双链表：可以逆向检索</p>
<p>​	双链表的初始化（带头结点）</p>
<p>​	双链表不可随机存取，查找只能通过遍历实现</p>
<p>循环链表</p>
<p>​	单链表	从一个结点出发只能找到后续的结点</p>
<p>​	循环单链表	从一个结点出发，可以找到其他任何结点</p>
<p>​	循环双链表	形成了两个闭环</p>
<p>静态链表</p>
<p>数组下标充当指针</p>
<p>​	分配一整片连续的内存空间</p>
<h2 id="第三章">第三章</h2>
<h3 id="栈">栈</h3>
<p>只允许在一段进行插入或删除的线性表</p>
<p>栈顶：允许插入、删除的一端</p>
<p>栈底：不允许的那一端</p>
<p>顺序栈的缺点：大小不可变</p>
<p>共享栈：两个栈共享同一片空间</p>
<h3 id="队列">队列</h3>
<p>只允许在一端进行插入，在另一端进行删除</p>
<p>队头：删除</p>
<p>队尾：插入</p>
<p>顺序队列</p>
<p>链式队列</p>
<p>双端队列</p>
<p>栈中合法的序列，双端队列中必定合法</p>
<p>​	输入受限的双端队列：4213 4231是非法的</p>
<p>​	输出受限的双端队列：4132 4231是非法的</p>
<p>括号匹配问题：利用栈的特性</p>
<p>​	遇到左括号入栈，遇到右括号出栈配对</p>
<h3 id="中缀表达式">中缀表达式</h3>
<p>运算符在两个操作数中间</p>
<p>​		中缀转后缀(手算)：左运算符优先原则</p>
<p>​		中缀转后缀(机算)：三种情况</p>
<p>​		中缀转前缀(手算)：右运算符优先原则</p>
<p>​		中缀的计算(机算)：中缀转后缀+后缀表达式求值	两个算法的结合</p>
<h3 id="后缀表达式">后缀表达式</h3>
<p>运算符在两个操作数后面</p>
<p>​		后缀的计算(机算)：栈实现</p>
<h3 id="前缀表达式">前缀表达式</h3>
<p>运算符在两个操作数前面</p>
<p>​		前缀的计算：栈实现</p>
<h3 id="栈的应用">栈的应用</h3>
<p>递归</p>
<p>缺点：</p>
<p>​	递归层数太多会导致栈溢出</p>
<p>​	包含很多重复计算</p>
<h3 id="队列的应用">队列的应用</h3>
<p>树的层次遍历</p>
<p>图的广度优先遍历</p>
<h3 id="矩阵的压缩存储">矩阵的压缩存储</h3>
<p>一维数组</p>
<p>二维数组</p>
<p>​	行优先存储</p>
<p>​	列优先存储</p>
<p>特殊矩阵</p>
<p>​	对称矩阵	只存储主对角线+下三角区</p>
<p>​						按行优先将个元素存入一维数组中</p>
<p>​	三角矩阵	上三角和下三角矩阵</p>
<p>​						将行优先原则将区域元素存入一维数组中，并在最后一个位置存储常数</p>
<p>​	三对角矩阵/带状矩阵</p>
<p>​	稀疏矩阵	非零元素远远少于矩阵元素</p>
<p>​						顺序存储——三元组&lt;行，列，值&gt;</p>
<p>​						链式存储——十字链表法</p>
<h2 id="第四章串">第四章	串</h2>
<p>子串	主串</p>
<p>空串	空格串</p>
<p>串是一种特殊的线性表	数据元素之间呈线性关系</p>
<p>串的比较：越靠前越小</p>
<h3 id="串的顺序存储">串的顺序存储</h3>
<p>静态数组实现(定长顺序存储)</p>
<p>动态数组实现(堆分配存储 malloc)</p>
<h3 id="串的链式存储">串的链式存储</h3>
<h4 id="模式匹配">模式匹配</h4>
<p>在主串中找到与模式串相同的子串</p>
<p>①	朴素模式匹配算法	O(nm)</p>
<p>​				通过遍历依次进行对比</p>
<p>②	KMP算法	O(n+m)</p>
<p>​				求next数组</p>
<p>③	KMP算法优化</p>
<p>​				求nextval数组（对next数组的优化）</p>
<p>​</p>
<h2 id="第五章树">第五章	树</h2>
<p>空树：结点数为0的树</p>
<p>非空树：有且仅由一个根结点</p>
<p>叶子结点：终端结点</p>
<p>树是一种递归定义的数据结构	每个结点都可以看作根结点</p>
<h3 id="树的属性">树的属性</h3>
<p>​		结点的层次(深度)——从上往下数</p>
<p>​		结点的高度——从下往上数</p>
<p>​		树的高度(深度)——总共多少层</p>
<p>​		结点的度——有几个孩子(分支)</p>
<p>​		树的度——各结点的度的最大值</p>
<h3 id="树的常考性质">树的常考性质</h3>
<p>​		① 结点数=总度数+1</p>
<p>​				因为根节点是没有父母结点</p>
<p>​		② 度为m的树、m叉树的区别</p>
<h3 id="二叉树">二叉树</h3>
<p>空二叉树——结点数n为0</p>
<p>二叉树有5种状态</p>
<p>几种特殊的二叉树</p>
<p>满二叉树：长满分支的二叉树</p>
<p>​		特点：只有最后一层有叶子结点</p>
<p>​					不存在度为1的结点	只有2或0</p>
<p>​					编号，左孩子为2i，右孩子为2i+1</p>
<p>完全二叉树：每个结点和满二叉树的编号一一对应</p>
<p>​		特点：只有最后两层可能有叶子结点</p>
<p>​					最多只有一个度为1的结点</p>
<p>二叉排序树</p>
<p>平衡二叉树</p>
<h3 id="二叉树的常考性质">二叉树的常考性质</h3>
<p>结点数：n</p>
<p>n0=n2+1</p>
<p>n=n0+n1+n2</p>
<p>n=n1+2n2+1</p>
<p>树的结点数=总度数+1</p>
<h3 id="二叉树的存储结构">二叉树的存储结构</h3>
<p>二叉树的顺序存储：按层序遍历存储在数组中</p>
<p>二叉树的链式存储：二叉链表</p>
<p>​		找父节点——只能从根结点开始遍历寻找</p>
<p>三叉链表——方便找父结点</p>
<h3 id="二叉树的遍历">二叉树的遍历</h3>
<p>先序遍历：根左右		前缀表达式</p>
<p>中序遍历：左根右		中缀表达式（要加括号）</p>
<p>后序遍历：左右根		后缀表达式</p>
<p>求二叉树的深度</p>
<p>层序遍历：一层一层遍历</p>
<p>借用一个辅助队列</p>
<h3 id="由遍历序列构造二叉树">由遍历序列构造二叉树</h3>
<p>一个遍历序列可能对应多种二叉树形态，不能唯一确定一棵二叉树</p>
<p>一定要有一个中序序列</p>
<p>先+中：先序第一个是根结点	那么在中序序列中，根结点左边的就全都是它的左子树	然后递归，在先序中第二个就是左子树的根结点，剩下同理；右子树也同理</p>
<p>后+中：后序中最后一个是根结点	接着在中序中找到根结点，左边是左子树，右边是右子树，再递归，同理，后序找根结点，中序通过根结点的左右划分子树</p>
<p>层+中：层序第一个是根结点，第二个可以是左子树的根结点，第三个可以是右子树的根结点。所以先找根结点，再划分左右子树，递归</p>
<p>重点：找到树的根结点，并根据中序序列划分左右子树，再找到左右子树的根结点</p>
<p>如果不要中序序列，前序、后序、层序两两组合不能唯一确定一棵二叉树</p>
<h3 id="线索二叉树">线索二叉树</h3>
<p>指向前驱、后继的指针称为“线索”</p>
<p>n个结点的二叉树有n+1个空链域，可以用来记录前驱、后继</p>
<p>tag==0	表示指针指向孩子</p>
<p>tag==1	表示指针是线索</p>
<p>中序线索二叉树	线索指向中序前驱、中序后继</p>
<p>先序线索二叉树	线索指向先序前驱、先序后继</p>
<p>后序线索二叉树	线索指向后序前驱、后序后继</p>
<p>线索化：一边遍历一边线索化</p>
<p>中序线索二叉树找中序前驱、后继</p>
<p>先序线索二叉树找先序前驱、后继</p>
<p>后序线索二叉树找后序前驱、后继</p>
<h3 id="二叉排序树">二叉排序树</h3>
<p>(又称二叉查找树)</p>
<h3 id="哈夫曼树">哈夫曼树</h3>
<p>结点的权：有某种数值</p>
<p>结点的带权路径长度：路径长度 × 权值</p>
<h3 id="哈夫曼编码">哈夫曼编码</h3>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[面向对象程序设计（期末复习）]]></title>
        <id>https://amadeus075.github.io/post/mian-xiang-dui-xiang-cheng-xu-she-ji-qi-mo-fu-xi/</id>
        <link href="https://amadeus075.github.io/post/mian-xiang-dui-xiang-cheng-xu-she-ji-qi-mo-fu-xi/">
        </link>
        <updated>2021-09-27T12:59:20.000Z</updated>
        <content type="html"><![CDATA[<h1 id="食用说明">食用说明</h1>
<p>历年卷中涉及到的书本页数，是以计算机学院 李青老师编写的C++书籍（蓝色的，忘记名字了，书也送给学弟了）为标准。</p>
<p>历年卷老师应该会在复习课之前发电子版。</p>
<p>其余复习资料可在我的Github仓库中找到，Github链接在博主的头像下方可以找到。</p>
<p>本文很大程度上参考了一位学长的博客，本人并不认识他，故仅附其博客地址：</p>
<blockquote>
<p>https://www.cnblogs.com/aoru45/p/9897269.html	C++ 历年试题解析（一）--判断题</p>
<p>https://www.cnblogs.com/aoru45/category/1335888.html	随笔分类：C++</p>
</blockquote>
<p>在当时的复习阶段靠学长的笔记学到了很多，非常感谢这位学长。</p>
<h1 id="课堂笔记">课堂笔记</h1>
<p>考试：<br>
浅赋值、深赋值<br>
浅拷贝、深拷贝</p>
<p>函数类模板里是否允许含有一个其他的类模板或函数模板<br>
（类模板里可以有新的类模板吗）</p>
<p>函数模板里是否允许有其他的函数定义<br>
（函数模板里可以定义新的函数吗）</p>
<p>数组和函数不能引用<br>
只有常量、变量有引用</p>
<p>模板里面可以含多个未知数据类型，我们是学了简单的一个未知类型</p>
<p>考题：<br>
1）涉及多个交换变量的函数(年年都考)<br>
2）两个字符串函数<br>
3）引用</p>
<p>考试总共有4大题<br>
1、2大题是送分的<br>
3、4考验编程能力</p>
<p>最后一大题，就算写个函数头也是有分的<br>
（向量、复数、矩阵）</p>
<p>4套卷子的第一部分一定要都对</p>
<h1 id="历年卷">历年卷</h1>
<h2 id="18届面向对象考卷">18届面向对象考卷</h2>
<h3 id="一-判断">一、判断</h3>
<p>1、</p>
<p>如果没有定义任何构造函数，则编译器会自动定义默认构造函数，其形式如 testClass() {};</p>
<p>可以看出，编译器自动提供的默认构造函数什么也没有。</p>
<p>如果程序猿没有定义任何构造函数，则编译器会自动定义默认构造函数，其形式如 testClass() {};  可以看出，编译器自动提供的默认构造函数是 啥也没有啊 ；</p>
<p>只要手动定义了构造函数，编译器就不会再提供默认构造函数了。</p>
<p>2、P244	this指针常量</p>
<p><strong>this指针的用处:</strong></p>
<p>一个对象的this指针并不是对象本身的一部分，不会影响sizeof(对象)的结果。</p>
<p>this作用域是在类内部，当在类的非静态成员函数中访问类的非静态成员的时候，编译器会自动将对象本身的地址作为一个隐含参数传递给函数。也就是说，即使你没有写上this指针，编译器在编译的时候也是加上this的，它作为非静态成员函数的隐含形参，对各成员的访问均通过this进行。例如，调用date.SetMonth(9) &lt;===&gt; SetMonth(&amp;date, 9)，this帮助完成了这一转换 .</p>
<p>在成员函数内部，我们可以直接使用调用该函数的对象的成员，而无需通过成员访问运算符来做到这一点，因为this所指的正是这个对象。任何对类成员的直接访问都被看成this的隐式使用。</p>
<p><strong>this的目的总是指向这个对象，所以this是一个常量指针，我们不允许改变this中保存的地址</strong></p>
<p>①this指针的特性：<br>
a.)this指针的类型：类类型 *const;<br>
b.)this指针并不是对象的一部分，不会影响对象的大小；<br>
c.)this指针是非静态成员函数的第一个隐含指针形参，是编译器自己处理的，我们不能在成员函数的形参中添加this指针的参数定义，也不能在调用时显示传递对象的地址给this指针;</p>
<p>3、P245	常量成员函数</p>
<p>​		常量成员函数是类的成员函数，这种函数的隐含形式参数为指向本对象的常量指针常量(const 类名* const this) ，故在函数体内只能读取但不能修改本对象的任何属性。</p>
<p>4、P263、264	拷贝构造函数</p>
<p>​		局部自动对象（包括值传递的形参对象）在其所在函数每一次调用时创建，函数返回后析构。</p>
<p>5、</p>
<p>6、P340	派生类对基类的兼容性</p>
<p>​		派生类的对象可以初始化（拷贝构造）基类的对象、初始化基类的引用，可以赋值给基类的对象。派生类对象的地址可以初始化基类的指针变量，可以赋值给基类的指针变量。这种特性成为派生类对象对基类对象的初始化及赋值兼容性。</p>
<p>7、P338	派生类的构造与析构</p>
<p>​		基类的私有成员在派生类中是存在的，但是被隔离起来，不能直接访问。</p>
<p>8、P348	抽象类</p>
<p>​		不能创建抽象类的对象；可以定义抽象类的指针变量指向由其派生的具体类的对象；可以声明抽象类的引用，声明引用时必须用其派生的具体类的对象进行初始化。</p>
<p>9、P309	重载运算符</p>
<p>​		C++不允许用户自己定义新的运算符，只能对已有的部分运算符进行重载；不允许改变运算符操作数的个数（自然不允许使用带默认值的参数）；不能改变运算符的运算优先级；不能改变运算符的运算结合方向。</p>
<p>10、P309	重载运算符</p>
<p>​		C++不允许用户自己定义新的运算符，只能对已有的部分运算符进行重载；不允许改变运算符操作数的个数（自然不允许使用带默认值的参数）；不能改变运算符的运算优先级；不能改变运算符的运算结合方向。</p>
<h3 id="二-填空">二、填空</h3>
<p>函数模板的格式P175</p>
<h3 id="三-阅读程序写出结果及简答题">三、阅读程序写出结果及简答题</h3>
<p>注意：对象构造与析构的顺序</p>
<h3 id="四-完成类的设计">四、完成类的设计</h3>
<h2 id="17届面向对象考卷直招">17届面向对象考卷(直招)</h2>
<h3 id="一-判断-2">一、判断</h3>
<p>1、P244	this指针常量</p>
<p>​		C++编译器为所有非静态成员函数添加了一个隐含的形式参数，其数据类型为指针常量，参数名为C++保留字this，意味着this的指向被锁定不能更改。</p>
<p>2、解释：p能再使用，delete释放的是p指向内存的空间，不过指向有点问题。所以delete之后还是让p指向NULL吧，这也是我们经常应当做的。</p>
<p>3、P251,252	类模板和模板类</p>
<p>​		编译系统并不编译类模板，只有遇到全部确定了的待定数据类型后，由编译系统先自动生成一个实际的类——成为模板类，然后再对该模板类进行编译。</p>
<p>4、P299	友元类</p>
<p>​		可以声明一个类是另一个类的友元，成为友元类。</p>
<p>5、P290	静态成员函数</p>
<p>​		当有具体对象存在时可以采用对象访问成员的方式访问类的静态数据成员（当然还取决于该静态数据成员的访问控制属性）。</p>
<p>​		对象名.静态数据成员名</p>
<p>​		更一般的方法是只用类名而不用对象名。</p>
<p>​		类名::静态数据成员名</p>
<p>6、P309	重载运算符</p>
<p>​		C++不允许用户自己定义新的运算符，只能对已有的部分运算符进行重载；不允许改变运算符操作数的个数（自然不允许使用带默认值的参数）；不能改变运算符的运算优先级；不能改变运算符的运算结合方向。</p>
<p>7、P163	函数调用</p>
<p>​		函数形式参数的生命期存在于函数被调用时，在调用该函数时产生，用实际参数对其进行初始化，函数返回时销毁形式参数。</p>
<p>8、P163	函数调用</p>
<p>9、P338	派生类对象的构造</p>
<p>​		当派生类对象生成的时候会调用构造函数，首先调用基类的构造函数生成基类部分，然后调用自己的构造函数，析构的时候顺序正好相反，先析构自身的然后析构释放派生类的</p>
<p>10、P348	抽象类</p>
<p>​		至少含有一个纯虚函数的类称为抽象类。</p>
<p>​		不能创建抽象类的对象；可以定义抽象类的指针变量指向由其派生的具体类的对象；可以声明抽象类的引用，声明引用时必须用其派生的具体类的对象进行初始化。</p>
<h3 id="二-填空-2">二、填空</h3>
<pre><code>using namespace std;
</code></pre>
<p>注意看 上下类似的代码，有没有引用 <strong>&amp;</strong></p>
<p>运算符重载注意是友元函数，开头加 <strong>friend</strong></p>
<h3 id="三-阅读程序写出结果及简答题-2">三、阅读程序写出结果及简答题</h3>
<h3 id="四-完成类的设计-2">四、完成类的设计</h3>
<h2 id="17届面向对象考卷">17届面向对象考卷</h2>
<h3 id="一-判断-3">一、判断</h3>
<p>1、P345	重载运算符的多态性</p>
<p>2、解释：试了一下，p还真能再使用，所以不要理解错了，delete释放的是p指向内存的空间，他自己还活着，不过指向有点问题，所以delete之后还是让p指向NULL吧，这也是我们经常应当做的。</p>
<p>3、sizeof 运算符：以字节为单位返回运算对象的大小（1字节定义为char类型占用的空间大小），若运算对象是类型（如，float），则必须用圆括号将其括起来。</p>
<p>4、P275	冒号语法</p>
<p>5、P252	模板类的编译</p>
<p>6、P289	静态数据成员</p>
<p>7、P316	重载运算符  后++</p>
<p>8、P335	继承</p>
<p>9、P245	两个const的作用</p>
<p><strong>常量指针</strong>：指向常量的指针，例如const int *p = &amp;a,可以改变p的指向，但是指向的必须是常量。</p>
<p><strong>指针常量</strong>：就是常指针，例如int * const p = &amp; a ，可以修改p指向的变量的值，但是p的指向改不了。</p>
<p>10、</p>
<p><strong>首先先给出几个概念：</strong></p>
<p><strong>1）类对象在创建时会调用构造函数，在释放是会调用析构函数；</strong></p>
<p><strong>2）函数中的局部变量在函数返回后，会由于弹栈从而内存被释放；</strong></p>
<p><strong>3）如果函数参数是采用值传递的方式传入类对象，则由于值传递的性质，先调用类复制构造函数产生一个临时对象，然后在函数返回后会调用类析构函数将该临时对象内存释放；</strong></p>
<p><strong>所以在对类对象进行参数传递的过程中，采用引用传递是一个正确的方式。</strong></p>
<p>其实这个坑也说明了一个问题，<strong>复制构造函数为什么是采用引用传递的形式，而不是采用值传递</strong>。假如采用值传递的方式，会导致什么样的后果？（会无限递归调用复制构造函数，当然实际过程中代码是不会通过编译的）</p>
<h3 id="二-填空-3">二、填空</h3>
<p>注意参数的类型</p>
<p>注意：<code>char *p = new char [strlen(x) +1];</code></p>
<h3 id="三-阅读程序写出结果及简答题-3">三、阅读程序写出结果及简答题</h3>
<h3 id="四-完成类的设计-3">四、完成类的设计</h3>
<h2 id="16届面向对象考卷">16届面向对象考卷</h2>
<h3 id="一-判断-4">一、判断</h3>
<p>1、P241	成员的访问控制</p>
<p>2、P258	构造函数</p>
<p>3、P264	拷贝构造函数</p>
<p>只有在定义初始化时调用构造函数<br>
构造函数不能被直接调用,必须在创建对象时才会自动调用</p>
<p>4、P243 	对象的基本空间</p>
<p>​	  P268 	对象的资源空间</p>
<p>5、P243	对象的基本空间</p>
<p>6、P289-290	静态数据成员</p>
<p>7、</p>
<p>8、P244  	this指针常量</p>
<p>9、P332  	继承</p>
<p>10、P309	重载运算符</p>
<h3 id="二-填空-4">二、填空</h3>
<h3 id="三-阅读程序写出结果及简答题-4">三、阅读程序写出结果及简答题</h3>
<h3 id="四-完成类的设计-4">四、完成类的设计</h3>
<h1 id="自己搜集的题目">自己搜集的题目</h1>
<p>1.C++中的struct和class有什么区别？<br>
【答案】从语法上讲，class和struct做类型定义时只有两点区别：<br>
(1)默认<strong>继承权限</strong>。如果不明确指定，来自class的继承按照private继承处理，来自struct的继承按照public继承处理；<br>
(2)成员的默认<strong>访问权限</strong>。class的成员默认是private权限，struct默认是public权限。 除了这两点，class和struct基本就是一个东西。语法上没有任何其它区别。<br>
（敲黑板：继承和访问权限不同，struct为public，class为private）</p>
<p>2.“引用”与指针的区别是什么？<br>
【答案】指针通过某个指针变量指向一个对象后，对它所指向的变量间接操作。程序中使用指针，程序的可读性差；而引用本身就是目标变量的别名，对引用的操作就是对目标变量的操作。</p>
<ol start="3">
<li></li>
</ol>
<p><code>class A {</code><br>
<code>virtual void func1()；</code><br>
<code>void func2();</code><br>
<code>} ；</code><br>
<code>class B: class A</code><br>
<code>{</code><br>
<code>void func1(){</code><br>
<code>cout &lt; &lt; “func1 in class B” &lt; &lt; endl;}</code><br>
<code>virtual void func2(){cout &lt; &lt; “fun2 in class B” &lt; &lt; endl;}</code><br>
<code>}</code><br>
A. A中的func1和B中的func2都是虚函数.<br>
B. A中的func1和B中的func2都不是虚函数.<br>
C. A中的func2是虚函数，B中的func1不是虚函数.<br>
D. A中的func2不是虚函数，B中的func1是虚函数.<br>
【答案】A</p>
<p>4.某文件中定义的静态全局变量(或称静态外部变量)其作用域是 ()?<br>
A.只限某个函数 B.本文件 C.跨文件 D.不限制作用域<br>
【答案】B。静态全局变量则限制了其作用域， 即只在定义该变量的源文件内有效， 在同一源程序的其它源文件中不能使用它。由于静态全局变量的作用域局限于一个源文件内，只能为该源文件内的函数公用， 因此可以避免在其它源文件中引起错误。</p>
<p>5.C++函数中值的传递方式有哪几种?<br>
【答案】C++函数的三种传递方式为：值传递、指针传递和引用传递。</p>
<p>6.引用与指针有什么区别？<br>
【答案】</p>
<ol>
<li>引用创建时必须同时被初始化，指针可以在任何时候初始化。</li>
<li>引用初始化后不能改变引用关系，指针能随时改变所指的对象。</li>
<li>不存在指向空值的引用，但是存在指向空值的指针。</li>
</ol>
<p>7.C++中virtual的含义分别是什么？<br>
【答案】<br>
在基类成员函数的声明前加上virtual关键字，意味着将该成员函数声明为虚函数。<br>
虚函数的特点：如果希望派生类能够重新定义基类的方法，则在基类中将该方法定义为虚方法，这样可以启用动态联编。</p>
<p>8.有了 malloc/free 为什么还要 new/delete？<br>
【答案】<br>
malloc 与 free 是 C++/C 语言的标准库函数，new/delete 是 C++的运算符。它们都可用于申请动态内存和释放内存。 对于非内部数据类型的对象而言，光用 maloc/free 无法满足动态对象的要求。对象在创建的同时要自动执行构造函数，对象在消亡之前要自动执行析构函数。由于malloc/free 是库函数而不是运算符，不在编译器控制权限之内，不能够把执行构造函数和析构函数的任务强加malloc/free。 因此 C++语言需要一个能完成动态内存分配和初始化工作的运算符 new，以及一个能完成清理与释放内存工作的运算符 delete。注意 new/delete 不是库函数。</p>
<p>9.const 符号常量：<br>
(1)const char *p<br>
(2)char const *p<br>
(3)char * const p<br>
说明上面三种描述的区别；</p>
<p>(1)p是一个指向const char的指针，p是可以改变指向的，但是p指向的值是不能改变的;</p>
<p>(2)p指向的恰好是一个指向const的char的普通指针；</p>
<p>(3)p是一个指针，这个指针是指向char的const指针。(1)和(2)的定义是一样的。</p>
<p>10.多态类中的虚函数表是Compile-Time，还是Run-Time时建立的?<br>
【答案】虚拟函数表是在编译期就建立了,各个虚拟函数这时被组织成了一个虚拟函数的入口地址的数组.而对象的隐藏成员–虚拟函数表指针是在运行期–也就是构造函数被调用时进行初始化的,这是实现多态的关键。</p>
<p>11.若数组名作实参而指针变量作形参，函数调用实参传给形参的是()<br>
A.数组的长度<br>
B.数组第一个元素的值<br>
C.数组所有元素的值<br>
D.数组第一个元素的地址<br>
【答案】D</p>
<p>12.变量的指针含意是指变量的 ()<br>
A.值<br>
B.地址<br>
C.存储<br>
D.名字<br>
【答案】B</p>
<p>13.内存的分配方式有几种?<br>
【答案】<br>
（1）从静态存储区域分配。内存在程序编译的时候就已经分配好，这块内存在程序的整个运行期间都存在。例如全局变量。<br>
（2）在栈上创建。在执行函数时，函数内局部变量的存储单元都可以在栈上创建，函数执行结束时这些存储单元自动被释放。栈内存分配运算内置于处理器的指令集中，效率很高，但是分配的内存容量有限。<br>
（3）从堆上分配，亦称动态内存分配。程序在运行的时候用malloc或new申请任意多少的内存，程序员自己负责在何时用free或delete释放内存。动态内存的生存期由我们决定，使用非常灵活，但问题也最多。</p>
<p>14.全局变量和局部变量有什么区别？是怎么实现的？操作系统和编译器是怎么知道的？<br>
【答案】</p>
<p>生命周期不同：全局变量随主程序创建和创建，随主程序销毁而销毁；局部变量在局部函数内部，甚至局部循环体等内部存在，退出就不存在； 内存中分配在全局数据区。</p>
<p>使用方式不同：通过声明后全局变量程序的各个部分都可以用到；局部变量只能在局部使用，分配在栈区。 操作系统和编译器通过内存分配的位置来知道的，全局变量分配在全局数据段并且在程序开始运行的时候被加载。局部变量则分配在堆栈里面 。</p>
<p>15.为什么数组名作为参数，会改变数组的内容，而其它类型如int却不会改变变量的值？<br>
【答案】当数组名作为参数时，传递的实际上是地址。而其他类型如int作为参数时，由于函数参数值实质上是实参的一份拷贝，被调函数内部对形参的改变并不影响实参的值。</p>
<p>16.const关键字？有哪些作用<br>
【答案】<br>
const关键字至少有下列n个作用：<br>
（1）欲阻止一个变量被改变，可以使用const关键字。在定义该const变量时，通常需要对它进行初始化，因为以后就没有机会再去改变它了；<br>
（2）对指针来说，可以指定指针本身为const，也可以指定指针所指的数据为const，或二者同时指定为const；<br>
（3）在一个函数声明中，const可以修饰形参，表明它是一个输入参数，在函数内部不能改变其值；<br>
（4）对于类的成员函数，若指定其为const类型，则表明其是一个常函数，不能修改类的成员变量；<br>
（5）对于类的成员函数，有时候必须指定其返回值为const类型，以使得其返回值不为“左值”。</p>
<p>17.是不是一个父类写了一个virtual 函数，如果子类覆盖它的函数不加virtual ,也能实现多态?<br>
【答案】virtual修饰符会被隐形继承的。virtual可加可不加。子类的空间里有父类的所有变量(static除外)。同一个函数只存在一个实体(inline除外)。子类覆盖它的函数不加virtual ,也能实现多态。在子类的空间里，有父类的私有变量。私有变量不能直接访问。</p>
<p>18.面向对象的三个基本特征，并简单叙述之？<br>
【答案】<br>
（1）封装：将客观事物抽象成类，每个类对自身的数据和方法实行protection(private,protected,public)<br>
（2）继承：广义的继承有三种实现形式：实现继承（指使用基类的属性和方法而无需额外编码的能力）、可视继承（子窗体使用父窗体的外观和实现代码）、接口继承（仅使用属性和方法，实现滞后到子类实现）。前两种（类继承）和后一种（对象组合=&gt;接口继承以及纯虚函数）构成了功能复用的两种方式。<br>
（3）多态：是将父对象设置成为和一个或更多的与他的子对象相等的技术，赋值之后，父对象就可以根据当前赋值给它的子对象的特性以不同的方式运作。简单的说，就是一句话：允许将子类类型的指针赋值给父类类型的指针。</p>
<p>19.重载（overload)、重写(override，有的书也叫做“覆盖”）、重定义（redefinition）的区别？<br>
【答案】</p>
<table>
<thead>
<tr>
<th>名称</th>
<th>名字空间</th>
<th>区别</th>
</tr>
</thead>
<tbody>
<tr>
<td>重载</td>
<td>同一名字子空间</td>
<td>是指允许存在多个同名函数，而这些函数的参数表不同。</td>
</tr>
<tr>
<td>重定义/隐藏</td>
<td>不同名字子空间</td>
<td>用于继承，派生类与基类的函数同名，屏蔽基类的函数</td>
</tr>
<tr>
<td>重写/覆盖</td>
<td>不同名字子空间</td>
<td>用于继承，子类重新定义父类虚函数的方法</td>
</tr>
</tbody>
</table>
<p>20.多态的作用？<br>
【答案】主要是两个：（1）隐藏实现细节，使得代码能够模块化；扩展代码模块，实现代码重用；（2）接口重用：为了类在继承和派生的时候，保证使用家族中任一类的实例的某一属性时的正确调用。</p>
<p>21.当一个类A 中没有声命任何成员变量与成员函数,这时sizeof(A)的值是多少，如果不是零，请解释一下编译器为什么没有让它为零。<br>
【答案】sizeof(A)= 1。编译器不允许一个类的大小为0，会为它分配1字节的内存。若不这样做，那2个类A的实例在内存中将会无法区分。 一个空类对象的大小是1byte。这是被编译器安插进去的一个字节，这样就使得这个空类的两个实例得以在内存中配置独一无二的地址。</p>
<p>22.如果ClassA中定义并实现虚函数int func(void)，ClassB中也实现该函数，那么上述变量a-&gt;func()将调用哪个类里面的函数？如果int func(void)不是虚函数，情况又如何？为什么？<br>
【答案】第一问调用的是B的。第二问调用A的。虚函数的一个典型应用，虚函数只能借助于指针或者引用来达到多态的效果。</p>
<p>23.请讲一讲析构函数和虚函数的用法和作用？<br>
【答案】析构函数是特殊的类成员函数，它没有返回类型，没有参数，不能随意调用，也没有重载，只有在类对象的生命期结束的时候，由系统自动调用，有释放内存空间的作用。虚函数是C++多态的一种表现, 使用虚函数，我们可以灵活的进行动态绑定，当然是以一定的开销为代价。</p>
<p>24.C++程序下列说法正确的有:<br>
A、对调用的虚函数和模板类都进行迟后编译.<br>
B、基类与子类中函数如果要构成虚函数,除了要求在基 类中用virtual 声名,而且必须名字相同且参数类型相同返回类型相同。<br>
C、重载的类成员函数都必须要:或者返回类型不同,或者参数数目不同,或者参数序列的类型不同.<br>
D、静态成员函数和内联函数不能是虚函数,友员函数和构造函数也不能是虚函数,但是析构函数可以是虚函数.<br>
【标准答案】A</p>
<p>25.在C++中有没有纯虚构造函数？<br>
【答案】构造函数不能是虚的。只能有虚的析构函数。</p>
<p>26.在c++的一个类中声明一个static成员变量的用处：<br>
【答案】在C++类的成员变量被声明为static（称为静态成员变量），意味着它为该类的所有实例所共享，也就是说当某个类的实例修改了该静态成员变量，也就是说不管创建多少对象，static修饰的变量只占有一块内存。其修改值为该类的其它所有实例所见；而类的静态成员函数也只能访问静态成员（变量或函数）。static是加了访问控制的全局变量，不被继承。</p>
<p>27.函数模板与类模板有什么区别？<br>
【答案】函数模板的实例化是由编译程序在处理函数调用时自动完成的，而类模板的实例化必须由程序员在程序中显式地指定</p>
<p>28、所有的运算符都能重载吗？<br>
【答案】不能被重载的运算符<br>
在 C++运算符集合中，有一些运算符是不允许被重载的。这种限制是出于安全方面的考虑，可防止错误和混乱。<br>
（1）不能改变 C++内部数据类型（如 int,float 等）的运算符。<br>
（2）不能重载‘.’，因为‘.’在类中对任何成员都有意义，已经成为标准用法。<br>
（3）不能重载目前 C++运算符集合中没有的符号，如#,@,$等。原因有两点，一是难以理解，二是难以确定优先级。<br>
（4）对已经存在的运算符进行重载时，不能改变优先级规则，否则将引起混乱。</p>
<p>29.基类的析构函数不是虚函数，会带来什么问题？<br>
【答案】派生类的析构函数用不上，会造成资源的泄漏。</p>
<p>30.写一个能做左值的函数(方法有很多)。如：<br>
<code>max(x, y) += 2874 + 55;</code><br>
<code>drwline(x, y)++;</code><br>
【答案】</p>
<pre><code class="language-cpp">int &amp;max(int &amp; x, int &amp; y)
{
     return x &gt; y? x : y;
}
int x = 55, y = 77;
max(x, y) += 12 + 11;                        // 此时 y = 100;
cout &lt;&lt; &quot;x = &quot;x &lt;&lt; &quot;;y = &quot;&lt;&lt; y &lt;&lt; endl;      // 输出 x = 55; y = 100;
</code></pre>
<p>31.以下三条输出语句分别输出什么？<br>
<code>char str1[] = “abc”;</code><br>
<code>char str2[] = “abc”;</code><br>
<code>const char str3[] = “abc”;</code><br>
<code>const char str4[] = “abc”;</code><br>
<code>const char* str5 = “abc”;</code><br>
<code>const char* str6 = “abc”;</code><br>
<code>cout &lt;&lt; boolalpha &lt;&lt; ( str1 == str2 ) &lt;&lt; endl; // 输出什么？</code><br>
<code>cout &lt;&lt; boolalpha &lt;&lt; ( str3 == str4 ) &lt;&lt; endl; // 输出什么？</code><br>
<code>cout &lt;&lt; boolalpha &lt;&lt; ( str5 == str6 ) &lt;&lt; endl; // 输出什么？</code><br>
【答案】分别输出false,false,true。str1和str2都是字符数组，每个都有其自己的存储区，它们的值则是各存储区首地址，不等；str3和str4同上，只是按const语义，它们所指向的数据区不能修改。str5和str6并非数组而是字符指针，并不分配存储区，其后的“abc”以常量形式存于静态数据区，而它们自己仅是指向该区首地址的指针，相等。</p>
<h1 id="重要知识点">重要知识点</h1>
<p>后记：当时因为懒只写了一点点，重要的知识不止这么点</p>
<h2 id="1常量指针和指针常量">1.常量指针和指针常量</h2>
<p><strong>常量指针</strong>：指向常量的指针，例如const int *p = &amp;a,可以改变p的指向，但是指向的必须是常量。</p>
<p><strong>指针常量</strong>：就是常指针，例如int * const p = &amp; a ，可以修改p指向的变量的值，但是p的指向改不了。</p>
<h2 id="2函数传参问题">2.函数传参问题</h2>
<p>void f(const int &amp;a) 可以传入表达式参数</p>
<p>void f(int &amp;a) 不能传入表达式参数</p>
<p>原因：表达式其实是一个函数，例如a+b返回的其实是个临时变量的值，传值过来就被视为常量，而c++规定引用传参不允许绑定常量，也就是说，引用必须引用的是一个变量，由于传来的是常量，所以不能引用。而前者是常引用，也就意味着可以引用常量，从而解决了表达式传参的问题。</p>
<h2 id="3只传部分参数返回结构体引发的生命周期问题">3.只传部分参数返回结构体引发的生命周期问题</h2>
<p><code>struct AA</code></p>
<p><code>{</code></p>
<p>​	  <code>int x;</code></p>
<p><code>}</code></p>
<p><code>AA *f(int a,int b,int c)</code></p>
<p><code>{</code></p>
<pre><code>`AA aa;`

 `AA * p = &amp;aa;`

 `aa.x = a + b +c;`

 `return p`
</code></pre>
<p><code>}</code></p>
<p>这个函数显然写的有问题，因为aa的生命周期在函数内，在函数外就没用了，因为返回指向aa的指针是没有意义的。</p>
<p>解决方法：</p>
<p>①动态生成结构体</p>
<p><code>A *p = new A();</code></p>
<p>这种new出来的结构体生命周期是在你delete之前一直存在的，所以符合要求，不过要记得在main函数执行完了或者在其他地方释放掉内存。</p>
<p>②局部静态结构体</p>
<p><code>static AA aa;</code></p>
<p>在AA aa 前加上static让他成为静态变量，这样生命周期就长于这个函数了，不过这样破坏了C++的局部可见性，不是很推荐。</p>
<p>然后其他的引用等方法没必要写了，太常规。</p>
<h2 id="4template知识点">4.Template知识点</h2>
<p>template想要处理多个数据类型不同的变量的时候，可以这么定义：</p>
<p><code>Template &lt;typename T,typename,P&gt;</code></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[本站的搭建原因]]></title>
        <id>https://amadeus075.github.io/post/ben-zhan-de-da-jian-yuan-yin/</id>
        <link href="https://amadeus075.github.io/post/ben-zhan-de-da-jian-yuan-yin/">
        </link>
        <updated>2021-09-27T05:24:34.000Z</updated>
        <content type="html"><![CDATA[<h1 id="近况">近况</h1>
<p>​	最近接了一个必须使用Rust的项目，涉及计算机视觉、计算机网络等方向。</p>
<p>​	由于学校神奇的课程安排，现在才刚刚开始学习计网，有很多知识点并不太了解；而且也根本没有接触过Rust语言，对着Rust程序设计语言硬啃没有什么正向反馈，写不出什么有意思的小项目，整个人很焦虑，所以想尝试做出一点新东西来跳出焦虑情绪。</p>
<p>​	最初想搭建博客的想法已经有大半年的时间了，那个时候别人推荐了Hugo，当时还想着了解一下Golang，没了解多少又要开始学Rust，还是希望自己能在某一语言或者领域深入一点，不要什么都只懂一点点。</p>
<p>​	最后感谢不是很懂但还是会仔细看我写的东西的笨蛋。</p>
<h1 id="博客内容">博客内容</h1>
<p>主要是发布一些学习笔记，现在主要是Python，以后可能有Rust，前提是自己学会。</p>
<p>还有就是大学课程的复习笔记，其实都发在了Github上，包括复习资料，但是小朋友们好像都不怎么会用，其中也有Github网络连接不稳定等因素，所以会将以前写的东西在这里重新发一遍。</p>
<h1 id="其他">其他</h1>
<p>顺便也把近期的学习情况和学习目标列一下吧，不然感觉没有什么监督，总是会摸鱼。</p>
<h2 id="阅读书目">阅读书目</h2>
<ul class="contains-task-list">
<li class="task-list-item">
<p><input class="task-list-item-checkbox" disabled="" type="checkbox" id="task-item-687390"><label class="task-list-item-label" for="task-item-687390"> 图解TCP/IP</label></p>
<p>​	在学校课程开始前阅读了一小半，后面因为忙别的事情搁置了，希望自己能看完</p>
</li>
<li class="task-list-item">
<p><input class="task-list-item-checkbox" disabled="" type="checkbox" id="task-item-3970999"><label class="task-list-item-label" for="task-item-3970999"> 计算机网络-自顶向下方法</label></p>
<p>​	打算读完图解TCP之后读</p>
</li>
<li class="task-list-item">
<p><input class="task-list-item-checkbox" checked="" disabled="" type="checkbox" id="task-item-5499060"><label class="task-list-item-label" for="task-item-5499060"> 鸟哥的Linux私房菜</label></p>
<p>​	也是在学校的OS课之前读的，进度50%吧，后面的章节感觉暂时不太用得上（？）</p>
</li>
<li class="task-list-item">
<p><input class="task-list-item-checkbox" disabled="" type="checkbox" id="task-item-1416035"><label class="task-list-item-label" for="task-item-1416035"> Rust程序设计语言</label></p>
<p>​	13/20章。还需要时间去消化和实际操作</p>
</li>
<li class="task-list-item">
<p><input class="task-list-item-checkbox" disabled="" type="checkbox" id="task-item-1299168"><label class="task-list-item-label" for="task-item-1299168"> 算法导论</label></p>
<p>​	发现老师是根据这本书而非课本进行讲课、布置题目的</p>
</li>
<li class="task-list-item">
<p><input class="task-list-item-checkbox" checked="" disabled="" type="checkbox" id="task-item-2894043"><label class="task-list-item-label" for="task-item-2894043"> 动手深度学习+PyTorch</label></p>
<p>​	暑假实习时扫过一遍</p>
</li>
<li class="task-list-item">
<p><input class="task-list-item-checkbox" checked="" disabled="" type="checkbox" id="task-item-1659477"><label class="task-list-item-label" for="task-item-1659477"> Linux就该这么学</label></p>
<p>​	不如鸟哥</p>
</li>
<li class="task-list-item">
<p><input class="task-list-item-checkbox" checked="" disabled="" type="checkbox" id="task-item-8556137"><label class="task-list-item-label" for="task-item-8556137"> 利用Python进行数据分析</label></p>
<p>​	暑假实习时扫过一遍</p>
</li>
<li class="task-list-item">
<p><input class="task-list-item-checkbox" checked="" disabled="" type="checkbox" id="task-item-303205"><label class="task-list-item-label" for="task-item-303205"> Python程序设计</label></p>
<p>​	为了恶补Python读的</p>
</li>
</ul>
<p><s>- [ ] Python编程快速上手—让繁琐工作自动化</s></p>
<p>​	    感觉排版和代码格式很不喜欢，放弃读了</p>
<ul class="contains-task-list">
<li class="task-list-item">
<p><input class="task-list-item-checkbox" disabled="" type="checkbox" id="task-item-5398829"><label class="task-list-item-label" for="task-item-5398829"> 数字图像处理</label></p>
<p>​	好多数学公式</p>
</li>
<li class="task-list-item">
<p><input class="task-list-item-checkbox" disabled="" type="checkbox" id="task-item-1911044"><label class="task-list-item-label" for="task-item-1911044"> python计算机视觉</label></p>
<p>​	课内实验大概要用到</p>
</li>
</ul>
<p>以上除了数字图像处理（第四版）入手了彩色纸质书外，其他都是电子书</p>
<p>有空闲时间了会把这些书（带书签）的获取方式贴在博客上，大概</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[使用说明（置顶）]]></title>
        <id>https://amadeus075.github.io/post/about/</id>
        <link href="https://amadeus075.github.io/post/about/">
        </link>
        <updated>2021-09-26T16:25:13.000Z</updated>
        <content type="html"><![CDATA[<blockquote>
<p>欢迎来到朝承恩的猫爬架 🤝</p>
</blockquote>
<h2 id="关于本站">🏠 关于本站</h2>
<p>本站主要用于满足表达欲、发布学习笔记，以及记录一些奇奇怪怪的想法。<br>
因为已有的社交平台已经沦落为沙雕猫图发布区，在那里并不想打破不发文字和自我想法的习惯。</p>
<h2 id="博主是谁">👨‍💻 博主是谁</h2>
<p>上海不知名高校    计算机科学与技术   学院及专业内底层人士   大学三年级学生<br>
朝承恩不是本名，本人不姓朝</p>
<h2 id="兴趣爱好">⛹ 兴趣爱好</h2>
<p>摸猫猫<br>
看笨蛋</p>
<h2 id="联系我呀">📬 联系我呀</h2>
<p>QQ：1073054587<br>
Github：Amadeus075<br>
Mail：Amadeus075@outlook.com</p>
]]></content>
    </entry>
</feed>