<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://amadeus075.github.io</id>
    <title>朝承恩的猫爬架</title>
    <updated>2021-10-11T04:52:19.453Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://amadeus075.github.io"/>
    <link rel="self" href="https://amadeus075.github.io/atom.xml"/>
    <subtitle>Purr for myself</subtitle>
    <logo>https://amadeus075.github.io/images/avatar.png</logo>
    <icon>https://amadeus075.github.io/favicon.ico</icon>
    <rights>All rights reserved 2021, 朝承恩的猫爬架</rights>
    <entry>
        <title type="html"><![CDATA[在服务器上的mmdetection食用说明]]></title>
        <id>https://amadeus075.github.io/post/zai-fu-wu-qi-shang-de-mmdetection-shi-yong-shuo-ming/</id>
        <link href="https://amadeus075.github.io/post/zai-fu-wu-qi-shang-de-mmdetection-shi-yong-shuo-ming/">
        </link>
        <updated>2021-09-28T03:21:57.000Z</updated>
        <content type="html"><![CDATA[<h1 id="mmdetection使用指南">mmdetection使用指南</h1>
<h2 id="连接服务器">连接服务器</h2>
<h3 id="启动docker某个image镜像的container容器">启动docker某个image（镜像）的container（容器）</h3>
<p>Docker的镜像称为image，容器称为container。</p>
<p>对于Docker来说，image是静态的，类似于操作系统快照，而container则是动态的，是image的运行实例。</p>
<p>比如，有一个image名称为ubuntu，那么比如现在我们启动这个image的container并且进入到这个container的bash命令行中：</p>
<pre><code>docker run -t -i ubuntu /bin/bash
</code></pre>
<p>这样就进入container的内部了：</p>
<pre><code>root@af8bae53bdd3:/#
</code></pre>
<p>如果有运行中的container，可以在container所在的外部操作系统中运行：</p>
<pre><code>docker ps
</code></pre>
<p>如果要退出就：</p>
<p>Ctrl-D</p>
<p>或：</p>
<pre><code>root@af8bae53bdd3:/# exit
</code></pre>
<h3 id="进入container容器">进入container（容器）</h3>
<p>要想退出container时，让container仍然在后台运行着，可以使用“docker exec -it”命令。每次使用这个命令进入container，当退出container后，container仍然在后台运行，命令使用方法如下：</p>
<ul>
<li><strong>txz-demo：要启动的container的名称</strong></li>
<li><strong>/bin/bash：在container中启动一个bash shell</strong></li>
</ul>
<pre><code>docker exec -it txz-demo /bin/bash
</code></pre>
<h2 id="数据处理">数据处理</h2>
<h3 id="1-voc转coco数据">1、VOC转COCO数据</h3>
<h4 id="voc格式与coco格式">VOC格式与COCO格式</h4>
<h5 id="xml的文件格式">XML的文件格式</h5>
<figure data-type="image" tabindex="1"><img src="https://i.loli.net/2021/09/28/MVgDPt8R9bU6Wr5.png" alt="image-20210803163739529" loading="lazy"></figure>
<p>可以看到一个xml文件包含如下信息：</p>
<ul>
<li>
<p><strong>folder</strong>: 文件夹</p>
</li>
<li>
<p><strong>filename</strong>：文件名</p>
</li>
<li>
<p><strong>path</strong>：路径</p>
</li>
<li>
<p>source：我项目里没有用到</p>
</li>
<li>
<p><strong>size</strong>：图片大小</p>
</li>
<li>
<p>segmented：图像分割会用到，本文仅以目标检测（bounding box为例进行介绍）</p>
</li>
<li>
<p>object</p>
<p>：一个xml文件可以有多个object，每个object表示一个box，每个box有如下信息组成：</p>
<ul>
<li><strong>name</strong>：改box框出来的object属于哪一类，例如Apple</li>
<li><strong>bndbox</strong>：给出左上角和右下角的坐标</li>
<li>truncated:略</li>
<li>difficult：略</li>
</ul>
</li>
</ul>
<h5 id="coco目录">COCO目录</h5>
<p>https://zhuanlan.zhihu.com/p/309549190</p>
<figure data-type="image" tabindex="2"><img src="https://i.loli.net/2021/09/28/5PyD81CYdhBHNKi.png" alt="image-20210803163926093" loading="lazy"></figure>
<p>或者annotations中只有两个json文件：train.json 和  val.json</p>
<figure data-type="image" tabindex="3"><img src="https://i.loli.net/2021/09/28/2kLCgKx9N3IFuOz.png" alt="image-20210803191443020" loading="lazy"></figure>
<h5 id="coco的json文件格式">COCO的json文件格式</h5>
<figure data-type="image" tabindex="4"><img src="https://i.loli.net/2021/09/28/MZHR5VyW2cD1pua.png" alt="image-20210803163951297" loading="lazy"></figure>
<h4 id="voc数据集格式转化成coco数据集格式">VOC数据集格式转化成COCO数据集格式</h4>
<p>https://www.pythonheidong.com/blog/article/322231/adafa1d556aea468052f/</p>
<p>代码修改<code>xml</code>和<code>json</code>路径即可运行。</p>
<p>结果：生成 train.json 和 val.json</p>
<p>官方推荐格式如下：</p>
<figure data-type="image" tabindex="5"><img src="https://i.loli.net/2021/09/28/ZtNkzOGp1gQbmFx.png" alt="image-20210804162829400" loading="lazy"></figure>
<p>但是不用严格按照该数据集，因为可以在如下路径中修改</p>
<pre><code class="language-python">/workspace/mmdetection/configs/_base_/datasets/coco_detection.py
</code></pre>
<figure data-type="image" tabindex="6"><img src="https://i.loli.net/2021/09/28/RHcxhfSoYUDK18W.png" alt="image-20210804163005721" loading="lazy"></figure>
<figure data-type="image" tabindex="7"><img src="https://i.loli.net/2021/09/28/SAI9dJQF14G3czZ.png" alt="image-20210804163021473" loading="lazy"></figure>
<figure data-type="image" tabindex="8"><img src="https://i.loli.net/2021/09/28/7UMeIF4L3lDHsJQ.png" alt="image-20210804163131036" loading="lazy"></figure>
<h3 id="2-config修改">2、config修改</h3>
<h4 id="标签">标签</h4>
<p>弯曲	1<br>
磕碰	2<br>
断柱	3<br>
断裂	4<br>
盲孔	5</p>
<p>用xml to coco.py生成train.json 和 val.json后，修改configs文件</p>
<p><code>mmdetection/configs/faster_rcnn/faster_rcnn_r101_fpn_1x_coco.py</code>	以该配置文件为例</p>
<h4 id="定义数据种类">定义数据种类</h4>
<p>把CLASSES的tuple改为自己数据集对应的种类tuple即可</p>
<p>注意：如果只有一个类，要加上一个逗号，否则将会报错。</p>
<pre><code class="language-python"># /workspace/mmdetection/mmdet/datasets/coco.py	 # 文件路径

    CLASSES = ('弯曲', '磕碰', '断柱', '断裂', '盲孔')	# 37行
</code></pre>
<pre><code class="language-python"># /workspace/mmdetection/mmdet/core/evaluation/class_names.py	# 文件路径
# 这个关系到后面test的时候结果图中显示的类别名称

def voc_classes():	# 如果用voc数据集，就改voc_classes
    return [
        '弯曲', '磕碰', '断柱', '断裂', '盲孔'
    ]
   
def coco_classes():	# 如果用coco数据集，就改coco_classes
    return [
        '弯曲', '磕碰', '断柱', '断裂', '盲孔'
    ]
</code></pre>
<h4 id="修改模型文件">修改模型文件</h4>
<p>（因为模型为faster_rcnn_r101_fpn_1x，所以配置对应的config文件）</p>
<p>找到<code>mmdetection/configs/faster_rcnn/faster_rcnn_r101_fpn_1x_coco.py</code>文件，打开后发现</p>
<pre><code class="language-python">_base_ = './faster_rcnn_r50_fpn_1x_coco.py'
</code></pre>
<p>继续沿着这个路径去找文件，发现指向的以下文件</p>
<pre><code class="language-python">_base_ = [
    '../_base_/models/faster_rcnn_r50_fpn.py',   
    #指向的是model dict，修改其中的num_classes类别为自己的类别。
    
    '../_base_/datasets/coco_detection.py',
    #data dict中的workers_per_gpu=2设置为0，train_pipeline和test_pipeline中的img_scale根据自己的图片尺寸修改。
    
    '../_base_/schedules/schedule_1x.py',
    #optimizer dict中修改学习率lr。当gpu数量为8时,lr=0.02；当gpu数量为4时,lr=0.01；我只有一个gpu，所以设置lr=0.0025
    
     '../_base_/default_runtime.py'
]

# 如果是voc数据集，改为以下：
# _base_ = [
#     '../_base_/models/faster_rcnn_r50_fpn.py',
#     '../_base_/datasets/voc0712.py',
#     '../_base_/schedules/schedule_1x.py', '../_base_/default_runtime.py'
# ]
</code></pre>
<h3 id="3-训练命令">3、训练命令</h3>
<h4 id="开始训练">开始训练</h4>
<p>训练前在mmdetection的目录下新建work_dirs文件夹。</p>
<p>重要：若改动框架源代码后，一定要注意重新编译后再使用。类似这里修改了几个源代码文件后再使用train命令之前，先要编译，执行下面命令。</p>
<pre><code class="language-python">pip install -v -e .  # or &quot;python setup.py develop&quot;
</code></pre>
<p>最后，执行训练指令。</p>
<p>错误命令：</p>
<pre><code class="language-python">python /workspace/mmdetection/tools/train.py /workspace/mmdetection/configs/faster_rcnn/faster_rcnn_r50_fpn_1x_coco.py \
--gpus 1 \
--work_dir /workspace/mmdetection/work_dir02
</code></pre>
<p>注意：work-dir 中间是-，不是_</p>
<p>正确命令：</p>
<pre><code class="language-python">cd mmdetection
python tools/train.py configs/faster_rcnn/faster_rcnn_r50_fpn_1x_coco.py   --work-dir work_dir02
</code></pre>
<p>训练参考：https://blog.csdn.net/weixin_42035347/article/details/118692679</p>
<p>训练结果显示：</p>
<figure data-type="image" tabindex="9"><img src="https://i.loli.net/2021/09/28/NgROftaHcBhCsmk.png" alt="image-20210804184054344" loading="lazy"></figure>
<h3 id="4-测试命令">4、测试命令</h3>
<h4 id="参数显示">参数显示</h4>
<p>测试命令	使用脚本test.py</p>
<pre><code class="language-python">python tools/test.py /workspace/mmdetection/configs/faster_rcnn/faster_rcnn_r50_fpn_1x_coco.py /workspace/mmdetection/work_dir02/epoch_12.pth --out /workspace/mmdetection/work_dir02/result/result.pkl --eval bbox
</code></pre>
<blockquote>
<p><code>configs/faster_rcnn/faster_rcnn_r50_fpn_1x_coco.py</code>：是模型文件<br>
<code>./work_dirs/my_faster_rcnn_r50_fpn_1x_coco/latest.pth</code>：是我们自己训练保存的模型<br>
<code>./result.pkl</code>：生成一个result.pkl文件，大小1.2M，该文件中会保存各个类别对应的信息，用于计算AP</p>
</blockquote>
<p>.pkl文件不能使用相对路径，要使用绝对路径，否则服务器会报错</p>
<p>如下是我测试的结果显示（测试集图片有11张）：</p>
<p>输出结果：</p>
<figure data-type="image" tabindex="10"><img src="https://i.loli.net/2021/09/28/PsdJGNlVzi9vFa7.png" alt="image-20210804192108149" loading="lazy"></figure>
<h4 id="预测图片并保存">预测图片并保存</h4>
<p>使用<code>--show-dir</code> 参数，可以把测试的检测图片检测结果保存到指定文件夹中，如下命令：</p>
<pre><code class="language-python">python tools/test.py ./configs/faster_rcnn/faster_rcnn_r50_fpn_1x_coco.py /workspace/mmdetection/work_dir02/epoch_12.pth --out /workspace/mmdetection/work_dir02/result/result.pkl --show-dir /workspace/mmdetection/work_dir02/test_hat_result
</code></pre>
<p>运行结果：</p>
<figure data-type="image" tabindex="11"><img src="https://i.loli.net/2021/09/28/kNmZJrzgsOycVjt.png" alt="image-20210804192430160" loading="lazy"></figure>
<p>生成的测试结果图片会被保存到`test_hat_result文件夹下，部分测试结果如下：</p>
<figure data-type="image" tabindex="12"><img src="https://i.loli.net/2021/09/28/bjOEDHN8gevFISa.png" alt="image-20210804192501245" loading="lazy"></figure>
<p>准确性不高</p>
<p>测试参考：https://blog.csdn.net/weixin_41010198/article/details/106258366</p>
<h1 id="报错">报错</h1>
<h2 id="mmdetection-20-没有show_result的问题">mmdetection 2.0 没有show_result的问题</h2>
<p>很多老旧版教材中有代码：</p>
<pre><code class="language-python">from mmdet.apis import init_detector, inference_detector, show_result
</code></pre>
<p>应更改为：</p>
<pre><code class="language-python">from mmdet.apis import inference_detector, init_detector, show_result_pyplot
	# 函数使用方法为：
	show_result_pyplot(model, img, result)
</code></pre>
<blockquote>
<p>参考：</p>
<p>https://blog.csdn.net/W1995S/article/details/117330783</p>
</blockquote>
<h2 id="modulenotfounderror-no-module-named-mmcv_ext解决方案">ModuleNotFoundError: No module named ‘mmcv._ext‘解决方案</h2>
<p>可能是你在开始安装mmcv-full的时候，没有指定版本，选择直接安装</p>
<p>采用默认安装mmcv-full的方式，如果与你环境里的cuda和torch版本不匹配，就容易出现上面报错</p>
<p>解决方案：卸载原来的mmcv，重新安装正确版本的mmcv-full</p>
<blockquote>
<p>参考：</p>
<p>https://blog.csdn.net/wjinjie/article/details/115164251</p>
</blockquote>
<h1 id="参考博客">参考博客</h1>
<h2 id="mmdetection20-环境搭建-训练自己的数据集-测试以及常见错误集合">mmdetection2.0 环境搭建、训练自己的数据集、测试以及常见错误集合</h2>
<p>https://shliang.blog.csdn.net/article/details/106258366</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[数据结构2 期末复习]]></title>
        <id>https://amadeus075.github.io/post/shu-ju-jie-gou-2-qi-mo-fu-xi/</id>
        <link href="https://amadeus075.github.io/post/shu-ju-jie-gou-2-qi-mo-fu-xi/">
        </link>
        <updated>2021-09-28T03:01:15.000Z</updated>
        <content type="html"><![CDATA[<h2 id="数据结构2习题集">数据结构2习题集</h2>
<p>《数据结构》第九章习题参考答案</p>
<p>https://wenku.baidu.com/view/baeb957e0342a8956bec0975f46527d3250ca61f.html</p>
<p>数据结构考试题</p>
<p>https://www.docin.com/p-571399345.html</p>
<p>http://www.doc88.com/p-674609483272.html</p>
<p>第十章复习题   看主页</p>
<p>https://wenku.baidu.com/view/af31b93a27284b73f2425065</p>
<h2 id="数据结构2-历年卷">数据结构2 历年卷</h2>
<h3 id="2015~2016">2015~2016</h3>
<h4 id="一-单选题">一、单选题</h4>
<p>1、</p>
<blockquote>
<p>上三角→有向图	对角线元素均为零→无环</p>
</blockquote>
<p>2、在一个带权连通图G中,权值最小的边一定包含在G的()种.</p>
<p>A.最小生成树	B.生成树 	C.广度优先生成树 	D.深度优先生成树</p>
<blockquote>
<p>A 最小生成树	这也是最小生成树的一个性质,构造最小生成树的方法都需要以此为基准<br>
其他各个答案没有必然性</p>
</blockquote>
<p>3、排序过程中，对尚未确定最终位置的所有元素进行一遍处理称为一趟排序。下列排序方法中，每一趟排序结束时都至少能够确定一个元素最终位置的方法是（）。</p>
<p>Ⅰ．简单选择排序</p>
<p>Ⅱ．希尔排序</p>
<p>Ⅲ．快速排序</p>
<p>Ⅳ．堆排序</p>
<p>Ⅴ．二路归并排序</p>
<blockquote>
<p>每一次排序之后都能确定至少一个元素位置的排序方法包括：</p>
<p>​		1.选择排序：每次将最大的数放到最后。所以最大的数排一次序后位置就确定了。</p>
<p>​		2.冒泡排序：同选择排序。每一次排序最大的值位置确定。</p>
<p>​		3.快排：每一次排序pivot的位置确定。</p>
<p>​		4.堆排序：每一次排序时，都是将堆顶的元素和最后一个节点互换，然后调整堆，再将堆大小减1。所以每一次排序堆顶元素确定。</p>
<p>不能至少确定一个元素的位置的方法包括：</p>
<p>​		1.插入排序：不到最后一步求的都是相对位置。</p>
<p>​		2.希尔排序：对简单插入排序的改进。不到最后一步，是无法确定每个元素位置的。</p>
<p>​		3.归并排序：局部有序，并不能确定任一元素在全局的位置。</p>
<p>​		4.基数排序，计数排序：利用桶排序的思路，不是基于比较的排序，也无法在一次排序中确定某个元素的位置。因为每一次排序都是整体处理。</p>
</blockquote>
<p>4、将森林F转换为对应的二叉树T，F中叶结点的个数等于 （）</p>
<blockquote>
<p>在二叉树中，节点的左指针指向其孩子，节点的右指针指向其兄弟。</p>
<p>所以在一颗二叉树中，如果某个节点的左指针为NULL，就说明这个节点在原来的森林中没有孩子，是叶子节点；如果某个节点的右指针为NULL，就说明这个节点在原来的森林中没有兄弟。</p>
<p>所以森林中的叶子节点=二叉树中左指针为NULL的个数</p>
</blockquote>
<figure data-type="image" tabindex="1"><img src="https://i.loli.net/2021/09/28/yWaQ89i2SdVlPBE.png" alt="image-20210613014902796" loading="lazy"></figure>
<p>5、分成3个等价类</p>
<blockquote>
<p>S1 = {1,2,3}</p>
<p>S2 = {4,5,6,7,9,10}</p>
<p>S3 = {8}</p>
</blockquote>
<p>6、下列选项中，不可能是快速排序第2趟排序结果的是 （）</p>
<blockquote>
<p>四个选项都是同样的数组元素，若完全有序，应为2345679</p>
<p>每经过一趟快排，轴点元素都必然就位，也就是说，一趟下来至少有1个元素在其最终位置</p>
<p>所以考察各个选项，看有几个元素就位即可。 A：2、3、6、7、9 	B：2、9	 C：9 	D：5、9 	第二趟至少应有2个元素就位，所以C不对。</p>
</blockquote>
<p>7、若将关键字1，2，3，4，5，6，7 依次插入到初始为空的平衡二叉树 T 中，则 T 中平衡因子为 0 的分支结点的个数是（ ）。</p>
<figure data-type="image" tabindex="2"><img src="https://i.loli.net/2021/09/28/vBOghMGFlKq1r8k.png" alt="image-20210613015258741" loading="lazy"></figure>
<blockquote>
<p>分支结点，即除去叶子结点的所有结点。</p>
</blockquote>
<blockquote>
<p>度为1或者2的结点为分支结点，度为零的为终端结点。</p>
</blockquote>
<p>8、</p>
<blockquote>
<p>A.顺序查找：对表的结构或关键字是否有序没有要求</p>
<p>B.折半查找：对有序表通常使用折半查找</p>
<p>C.插值查找：类似于折半查找</p>
<p>D.斐波那契查找：基于有序表的逐步缩小找区间的查找方法</p>
</blockquote>
<p>9、对于一个具有n个顶点和e条边的无向图，若采用<strong>邻接表</strong>表示，则表头向量的大小为( )，邻接表中的全部结点总数是( )</p>
<figure data-type="image" tabindex="3"><img src="https://i.loli.net/2021/09/28/g3f9X1a285qdCRw.png" alt="image-20210618110916301" loading="lazy"></figure>
<blockquote>
<p>严版教材163页倒数第三段“若无向图中有n个顶点、e条边，则它的<strong>邻接表</strong>需要n个头结点和2e个表结点”</p>
</blockquote>
<blockquote>
<p>邻接多重表中，每条边用一个结点表示，每个顶点也用一个结点表示</p>
<p>在无向图的邻接多重表中，图的每一条边用一个边结点表示</p>
</blockquote>
<p>10、查找效率最高的二叉排序树是</p>
<figure data-type="image" tabindex="4"><img src="https://i.loli.net/2021/09/28/q2ibynj67umE3XT.png" alt="image-20210618110933017" loading="lazy"></figure>
<blockquote>
<p>二叉排序树查找算法的平均查找长度，主要取决于树的高度，即与二叉树的形态有关。</p>
<p>如果二叉排序树是一个只有右(左)孩子的单支树，其平均查找长度和单链表相同为O(n)； 平衡二叉树的平均查找长度O(logN）。</p>
<p>补充:当有序表是静态查找表时，宜用顺序表作为其存储结构，而采用二分查找实现其查找操作；</p>
<p>当有序表是动态查找表时，应选择二叉排序树作为其逻辑结构</p>
</blockquote>
<blockquote>
<p>完全二叉树确实平衡（平衡因子绝对值小于等于一）</p>
</blockquote>
<h4 id="二-填空题">二、填空题</h4>
<p>1、假定一棵树的广义表表示为A（C，D（E，F，G），H（I，J）），则树的度为_________</p>
<blockquote>
<p>因为广义表本身是“嵌套”，这个表这么看：<br>
根是A，有三个孩子C,D,H<br>
D有三个孩子E,F,G<br>
H有两个孩子I,J<br>
根据这个结构就可以确定一颗树了，度为3.</p>
</blockquote>
<p>2、设有向图G的二元组形式表示为G =（D，R），D={1，2，3，4，5}，R = {&lt;1,2&gt;，&lt;2,4&gt;，&lt;4,5&gt;，&lt;1,3&gt;，❤️,2&gt;，❤️,5&gt;}，则给出该图的一种拓扑排序序列</p>
<blockquote>
<p>这就是根据R进行排序，由&lt;1,2&gt;，&lt;2,4&gt;，&lt;4,5&gt;可得&lt;1,2,4,5&gt;,由&lt;1,3&gt;，❤️,2&gt;可得&lt;1,3,2&gt;,</p>
<p>之后由  &lt;1,2,4,5&gt;  &lt;1,3,2&gt;得(1,3,2,4,5)</p>
</blockquote>
<p>3、散列法存储的基本思想是由<strong>关键码的值</strong>决定数据的存储地址。</p>
<figure data-type="image" tabindex="5"><img src="https://i.loli.net/2021/09/28/Ewce64oHSRtQGrq.png" alt="image-20210613020452126" loading="lazy"></figure>
<p>6、15次</p>
<blockquote>
<p>5趟：</p>
<p>5+4+3+2+1=15次比较</p>
</blockquote>
<p>7、2.9</p>
<p>例题：</p>
<figure data-type="image" tabindex="6"><img src="https://i.loli.net/2021/09/28/kNVv9izgGRfmpsQ.png" alt="image-20210613021052518" loading="lazy"></figure>
<p>同理，试卷题目的答案2.9=(1+4+12+12)/10</p>
<p>8、设某无向图中顶点数和边数分别为 n 和 e ，所有顶点的度数之和为 d ，则 e=</p>
<blockquote>
<p>无向图中的度的定义是：出度+入度=图的度数，故边数e为度数d的一半</p>
</blockquote>
<p>9、在一棵度为4的树T中，若有20个度为4的结点，10个度为3的结点，1个度为2的结点，10个度为1的结点，则树T的叶节点个数是（）</p>
<p>A.41</p>
<p>B.82</p>
<p>C.113</p>
<p>D.122</p>
<blockquote>
<p>正确答案是 B</p>
<p>除了根节点之外，树的每个节点都有唯一的一个入度，因此计算出共有多少出度，再加1就是树中总的节点数目。也就是20X4+10X3+1X2+10X1+1=123个<br>
而四叉树里节点就5类，有4个孩子的，有3个孩子的，有2个孩子的，有1个孩子的，没有孩子的，现在前4类的数目知道了，是20+10+1+10=41，那么没有孩子的节点自然就是123-41=82个。</p>
</blockquote>
<figure data-type="image" tabindex="7"><img src="https://i.loli.net/2021/09/28/tBKmM8S2ZGavkLn.png" alt="image-20210613021821830" loading="lazy"></figure>
<h4 id="三-是非题">三、是非题</h4>
<p>3、对一棵二叉排序树按（）遍历，可得到结点值从小到大的排列序列。<br>
A．先序<br>
B．中序<br>
C．后序<br>
D．层次</p>
<blockquote>
<p>【◆答案◆】：B   参考课本P274</p>
</blockquote>
<p>4、</p>
<figure data-type="image" tabindex="8"><img src="https://i.loli.net/2021/09/28/a3E9U6Q4L2hlemp.png" alt="image-20210613022711022" loading="lazy"></figure>
<blockquote>
<p>答案是B,  二叉排序树又叫二叉查找树，看课本P280相关概念就能得出答案</p>
</blockquote>
<p>5、</p>
<figure data-type="image" tabindex="9"><img src="https://i.loli.net/2021/09/28/8SbhH5klafIGqYJ.png" alt="image-20210613023252654" loading="lazy"></figure>
<blockquote>
<p>正确答案：B</p>
</blockquote>
<figure data-type="image" tabindex="10"><img src="https://i.loli.net/2021/09/28/5qIlkUuYVcy2S9t.png" alt="image-20210613023307048" loading="lazy"></figure>
<p>6、带权无向图的最小生成树是唯一的。（ ）</p>
<blockquote>
<p>无向图中连接同一个点相同权值的边不止一条的时候，最小生成树不唯一</p>
</blockquote>
<p>7、当向二叉排序树中插入一个结点，则该结点一定成为叶子结点。</p>
<blockquote>
<p>题目说的是二叉排序树，插入在叶子结点，不需要调整。</p>
<p>而AVL树才需要调整，此时不一定是叶子结点。</p>
</blockquote>
<p>8、对连通图进行深度优先遍历可以访问到该图中的所有顶点。（ ）</p>
<blockquote>
<p>对连通图进行深度优先遍历是可以访问到该图的所有顶点的。注意前提：该图为连通图，不存在孤立点的情况。</p>
</blockquote>
<p>9、</p>
<blockquote>
<p>课本P323  在简单选择排序中，关键字比较次数与数据元素的初始排列无关。</p>
</blockquote>
<p>10、用邻接矩阵作为图的存储结构时，则其所占用的存储空间与图中顶点数无关而与图中边数有关。 ( )</p>
<blockquote>
<p>图的邻接矩阵存储所占用空间大小只与顶点个数有关，更准确地说，设顶点n个，则与n^2成正比</p>
</blockquote>
<figure data-type="image" tabindex="11"><img src="https://i.loli.net/2021/09/28/jFLqc4HzN9J17ky.png" alt="image-20210613024336887" loading="lazy"></figure>
<h4 id="四-应用题">四、应用题</h4>
<h5 id="1-各种排序方法">1、各种排序方法</h5>
<h5 id="2-aoe网络图最短路径">2、AOE网络+图+最短路径</h5>
<h5 id="3-森林与二叉树">3、森林与二叉树</h5>
<p>https://blog.csdn.net/weixin_42356649/article/details/103036469</p>
<figure data-type="image" tabindex="12"><img src="https://i.loli.net/2021/09/28/X5rmJYQTH4dvsFU.png" alt="image-20210614213007035" loading="lazy"></figure>
<p>https://blog.csdn.net/u011240016/article/details/52824161</p>
<h5 id="4-查找算法">4、查找算法</h5>
<p>（1）二次探测再散列</p>
<ul>
<li>d<sub>i</sub>=1<sup>2</sup>,-1<sup>2</sup>,2<sup>2</sup>,-2<sup>2</sup>,...,k<sup>2</sup>,-k<sup>2</sup></li>
</ul>
<p>（2）散列查找的平均查找长度（成功、失败）</p>
<p>https://blog.csdn.net/qq_41475583/article/details/107225296</p>
<p>https://blog.csdn.net/wangran51/article/details/8826633/</p>
<p>（3）平衡二叉树</p>
<p>（4）B-树</p>
<h3 id="2012~2013">2012~2013</h3>
<h4 id="一-判断题">一、判断题</h4>
<p>1、任意一棵二叉树都可以转换为树来表示（F）</p>
<blockquote>
<p>任何一棵树都可以表示成二叉树，并不是任何一棵二叉树都可以表示成树。那么树多还是二叉树多？</p>
<ol>
<li>
<p>任何一棵树都可以表示成二叉树，结合以上题目很容易理解。</p>
</li>
<li>
<p>不是任何一棵二叉树都可以表示成树：</p>
<p>当根节点包含右子树的时候，就无法表示成树了。</p>
</li>
<li>
<p>树多还是二叉树多的问题：</p>
</li>
</ol>
<p>二叉树也是树的一种，如果按照包含关系来说，树肯定包含二叉树了，树多一些</p>
</blockquote>
<p>2、折半查找进行时间性能分析的判定树不一定是完全二叉树。  （T ）</p>
<blockquote>
<p>用二叉查找树（Binary Search Tree）来分析折半查找的查找性能</p>
</blockquote>
<figure data-type="image" tabindex="13"><img src="https://i.loli.net/2021/09/28/4tVd3qKmpcz8wEo.png" alt="image-20210614234015565" loading="lazy"></figure>
<p>3、散列表的平均查找长度只与采用的散列函数及处理冲突的方法有关。（ F ）</p>
<blockquote>
<p>冲突的出现，与散列函数的选取（地址分布是否均匀）、处理冲突的方法（是否产生堆积）有关</p>
</blockquote>
<p>4、对B树删除某一个关键字值时,可能引起结点的分裂	(F)</p>
<blockquote>
<p>不正确，删除时是:合并， 插入时是:分裂</p>
</blockquote>
<p>5、有e条边的无向图，在邻接表中有e个结点。(F)</p>
<blockquote>
<p>有n个头节点，2e个表节点</p>
</blockquote>
<p>6、十字链表是有向图的一种存储结构。（T）</p>
<blockquote>
<p>无向图存储：邻接矩阵、邻接表、邻接多重表</p>
<p>有向图存储：邻接矩阵、邻接表、十字链表</p>
</blockquote>
<p>7、不同的求最小生成树的方法最后得到的生成树是相同的. （F）</p>
<blockquote>
<p>最小生成树不唯一，但最小生成树上权值之和唯一</p>
</blockquote>
<blockquote>
<p>最小生成树算法：适用范围：无向图</p>
<p>其是完成的就是再保证这个图是连通图的同时，又能保证这个图的所有边的权值之和是最低的</p>
<p>最小生成树的算法：包含两个一个是Kruskal（克鲁斯卡尔）算法，一个是Prim（普里姆）算法</p>
<p>①克鲁斯卡尔算法：</p>
<p>首先来看克鲁斯卡尔算法，其是就是从小权重的边开始，考虑两块，一是不能产生回路，否则，该边舍弃，再选小权重的边，直至到所有顶点均构成回路为止，因为各边的权值可能相同，即可能出现边的最小权值之和的最优解不止一个。</p>
<p>②普里姆算法：</p>
<p>普里姆算法是按照点来实现的</p>
<p>逻辑实现：其实就是先从一个顶点开始，寻找权值最小的边，找到下一个顶点，解锁与该点所有相关的边，然后剩余的边中找到权值最小的边，看是否能解锁信的节点，不解锁，此边舍弃解锁，则把新解锁的顶点的所有边解锁，依次类推，直至所有节点都解锁为止，选中的边即为所求。P算法算出的最优解也可能不止一种。</p>
</blockquote>
<p>8、若一个有向图的邻接矩阵对角线以下元素均为零,则该图的拓扑有序序列必定存在。 (T)</p>
<blockquote>
<p>正确答案是 正确</p>
<p>对角线以下元素均为零，表明只有顶点i到顶点j（i&lt;j）可能有边，而顶点j到顶点i一定没有边，即有向图是一个无环图，因此一定存在拓扑序列，但是该拓扑序列不一定唯一，可以举反例证明。另外，若题目说对角线以上均为1，以下均为0，则拓扑序列唯一。</p>
</blockquote>
<p>9、顺序表上的直接选择排序是一种稳定的排序方法。     （  F  ）</p>
<img src="http://image.trouvaille0198.top/849589-20180402133438219-1946132192.png" style="zoom: 40%;" />
<blockquote>
<p>直接选择排序又称简单选择排序，是一种不稳定的排序方法，其是选择排序中最简单一种，其基本思想是：第 i 趟排序再待排序序列 a[i]~a[n] 中选取关键码最小的记录，并和第 i 个记录交换作为有序序列的第 i 个记录。</p>
<p>其实现利用双重循环，外层 i 控制当前序列最小值存放的数组元素位置，内层循环 j 控制从 i+1 到 n 序列中选择最小的元素所在位置 k</p>
<p>https://blog.csdn.net/u011815404/article/details/79256237</p>
<p>https://blog.51cto.com/boyishachang/1292315</p>
<p>基数排序，也被称为桶排序</p>
</blockquote>
<p>10、 对长度为n的表作快速排序，最坏情况下，算法时间复杂度为O(n2)。（  T  ）</p>
<blockquote>
<p>如上图</p>
</blockquote>
<h4 id="二-选择题">二、选择题</h4>
<p>1、如果要求一个线性表既能较快的查找，又能适应动态变化的要求，则可采用( 分块 )查找法。</p>
<blockquote>
<p>分块查找是折半查找和顺序查找的一种改进方法，折半查找虽然具有很好的性能，但其前提条件时线性表顺序存储而且按照关键码排序，这一前提条件在结点树很大且表元素动态变化时是难以满足的。而顺序查找可以解决表元素动态变化的要求，但查找效率很低。如果既要保持对线性表的查找具有较快的速度，又要能够满足表元素动态变化的要求，则可采用分块查找的方法。</p>
<p>分块查找的速度虽然不如折半查找算法，但比顺序查找算法快得多，同时又不需要对全部节点进行排序。当节点很多且块数很大时，对索引表可以采用折半查找，这样能够进一步提高查找的速度。</p>
<p>分块查找由于只要求索引表是有序的，对块内节点没有排序要求，因此特别适合于节点动态变化的情况。当增加或减少节以及节点的关键码改变时，只需将该节点调整到所在的块即可。在空间复杂性上，分块查找的主要代价是增加了一个辅助数组。</p>
</blockquote>
<p>2、在一个无向图中，所有顶点的度数之和等于所有边数（  2   ）倍。</p>
<p>3、用DFS遍历一个无环有向图，并在DFS算法退栈返回时打印相应的顶点，则输出的顶点序列是( 逆拓扑有序 )。</p>
<blockquote>
<p>DFS（深度优先遍历）  是一个递归算法,在遍历的过程中,先访问的点被压入栈底（栈是先进后出）</p>
<p>拓扑有序    是指如果点U到点V有一条弧,则在拓扑序列中U一定在V之前.深度优先算法搜索路径恰恰是一条弧,栈的输出是从最后一个被访问点开始输出,最后一个输出的点是第一个被访问的点.所以是逆的拓扑有序序列</p>
</blockquote>
<blockquote>
<p>用DFS遍历一个无环有向图，并在DFS算法退栈返回时打印相应的顶点，则输出的顶点序列是( )。</p>
<p>如果是队列：拓扑有序</p>
<p>如果是栈：逆拓扑有序</p>
</blockquote>
<p>4、下列哪一种图的邻接矩阵一定是对称矩阵（无向图）</p>
<blockquote>
<p>无向图，以斜边为对称</p>
</blockquote>
<p>5、用邻接矩阵A表示图，判定任意两个顶点Vi和Vj之间是否有长度为m 的路径相连，则只要检查（  A^m  ）的第i行第j列的元素是否为零即可</p>
<blockquote>
<p>长度为m，就求邻接矩阵A的m次方</p>
</blockquote>
<p>6、下面哪一个方法可以判断出一个有向图是否有环	(拓扑排序 )。</p>
<blockquote>
<p>关键路径能不能判断一个图有环还存在一些争议。关键路径本身虽然不允许有环，但求关键路径的算法本身无法判断是否有环，判断是否有环的是关键路径的第一步——拓扑排序。</p>
</blockquote>
<blockquote>
<p>B,拓扑排序就是在无环图才有解的</p>
</blockquote>
<p>7、在图采用邻接表存储时，求最小生成树的Prime算法的时间复杂度为（O(n+e)）</p>
<figure data-type="image" tabindex="14"><img src="https://i.loli.net/2021/09/28/hDSX4VRMmTfCJzK.png" alt="image-20210613025853989" loading="lazy"></figure>
<p>8、下列关于AOE网的叙述中，不正确的是（ B ）。</p>
<blockquote>
<p>关键活动组成了关键路径</p>
<p>关键路径是图中的最长路径</p>
<p>关键路径长度代表整个工期的最短完成时间</p>
<p>关键活动延期完成,必将导致关键路径长度增加,即整个工期的最短完成时间增加,因此A正确.</p>
<p>关键路径并不唯一,当有多条关键路径存在时,其中一条关键路径上的关键活动时间缩短,只能导致本条关键路径变成非关键路径,而无法缩短整个工期,因为其他关键路径没有变化,因此B项不正确.</p>
<p>对于A,B两项要搞懂的是,任何一条关键路径上的关键活动变长了,都会使这条关键路径变成更长的关键路径,并且导致其他关键路径变成非关键路径（如果关键路径不唯一）,因此整个工期延长.</p>
<p>而某些关键活动缩短则不一定缩短整个工期.</p>
<p>理解了A,B两项,C,D就很容易理解了</p>
</blockquote>
<blockquote>
<p>从源点到汇点的所有路径中， 具有<strong>最大路径长度</strong>的路径称为关键路径</p>
<p>对于关键路径，我们需要注意以下:</p>
<p>1.关键路径上的所有活动都是关键活动，他是决定整个工程的关键因素。</p>
<p>2.网中的关键路径并不唯一，对于有几条关键路径的网，必须加快那些包括在所有关键路径上的关键活动才能达到缩短工期的目的</p>
</blockquote>
<p>9、二叉查找树的查找效率与二叉树的树型有关，在（呈单枝树）时其查找效率最低</p>
<blockquote>
<p>当二叉查询树变成一条链表效率最差。所以有AVL平衡树——限制节点深度差不超过1，避免产生链表一般的树。</p>
</blockquote>
<blockquote>
<p>为了提高二叉排序树的查找效率，改进成二叉平衡树，通过不让左右子树的相对深度大于1来提高效率。而单枝必然违背了这个原理，效率低。</p>
</blockquote>
<p>10、设有一个用线性探测法解决冲突得到的散列表：散列函数为H(k)=k mod 11,若要查找元素14，探测的次数是( 6 )。</p>
<blockquote>
<p>14%11=3    X mod 11 =8, X=19   19-14+1=6次</p>
<p>由此可知，一旦发生冲突，则依次向后寻找“下一个”空桶Hi</p>
<p>即用线性探测序列H0 + 1 , H0 + 2，⋯，m-1，0 , 1 , 2，⋯，H0-1在表中寻找下一个空桶的桶号。</p>
<p>每当发生冲突后，就探测下一个桶。当循环m一1次后就会回到开始探测时的位置，说明待查数据元素不在表内，而且表己满，不能再进行插入。</p>
</blockquote>
<p>12、下列排序方法中，比较次数与待排序记录的初始状态无关的是（选择排序和基数排序）</p>
<blockquote>
<p>逐个分析下：</p>
<p>插入排序	 时间复杂度与比较次数、移动次数	都与初始序列<strong>有关</strong></p>
<p>快排 			时间复杂度与比较次数、移动次数	都与初始序列<strong>有关</strong></p>
<p>归并排序	 时间复杂度与初始序列<strong>无关</strong>，比较次数<strong>有关</strong>（有序序列），移动次数<strong>无关</strong>（无论怎么有序，还是每个元素拷贝到新的数组）</p>
<p>选择排序	 时间复杂度与初始序列<strong>无关</strong>，比较次数<strong>无关</strong>，移动次数<strong>无关</strong></p>
<p>冒泡排序	 时间复杂度与初始序列<strong>无关</strong>，比较次数<strong>无关</strong>，移动次数<strong>有关</strong></p>
</blockquote>
<blockquote>
<p>初始状态对归并排序的比较次数有影响，对其移动次数没影响。</p>
<p>与数组初始状态无关的内排序算法详解：</p>
<p>http://www.cnblogs.com/Xieyang-blog/p/8340578.html</p>
</blockquote>
<figure data-type="image" tabindex="15"><img src="https://i.loli.net/2021/09/28/ER5qmoZxXQy7laB.png" alt="image-20210615004237884" loading="lazy"></figure>
<figure data-type="image" tabindex="16"><img src="https://i.loli.net/2021/09/28/RLW3ZDwB4X89sKV.png" alt="image-20210615004246967" loading="lazy"></figure>
<p>13、设有5000个元素，希望用最快的速度挑选出前10个最大的，采用（ 堆排序 ）方法最好。</p>
<blockquote>
<p>一般来说：(Top K问题)找出N个数据中前K大(小)的K个数， 选堆排<br>
因为堆排序来解决 Top K 问题并不需要全部排序， 只需要维护一个大小为K的最大(小)堆。它的时间复杂度为O(nlogK)</p>
</blockquote>
<p>14、并查集的结构是（ 双亲表示法存储的树  ）</p>
<blockquote>
<p>用树的根结点来代表相应的等价类集合。在此，等价类树用双亲表示法表示。</p>
<p>课本P201</p>
</blockquote>
<p>15、下列哪一个关键码序列不符合堆的定义？（C）</p>
<blockquote>
<p>从答案看，都是小根堆关键码序列，根据小根堆的定义，<br>
<strong>K[i]＜=K[2i]</strong><br>
<strong>K[i]＜=K[2i+1]</strong><br>
用完全二叉树表示很直观，也就是要能组成这样一个完全二叉树：所有的父结点的值都应该小于左右孩子结点的值。</p>
<p>答案C中关键码序列用完全二叉树表示后很容易看出，在D结点值D大于右子结点值C，这不符合小根堆定义</p>
<p>同样在r结点值r大于了左子结点值M和右子结点值H。</p>
<p>而其他答案都符合小根堆定义。</p>
</blockquote>
<h4 id="三-填空题">三、填空题</h4>
<p>1、G是一个非连通无向图，共有28条边，则该图至少有（9）个顶点。</p>
<blockquote>
<p>n个顶点 最多拥有 n(n-1)/2条边，所以8个顶点最多有28条边，要想28条边而且保持非连通，至少要9个节点，第9个节点是孤立的，不与任何节点连通。</p>
</blockquote>
<blockquote>
<p>要使n个顶点的无向图连通，至少需要(n-1)(n-2)/2+1条边；即n=8时，至少需要23条边，无向图即可连通。</p>
<p>则要使图不连通，n=9</p>
<p>或者令(n-1)(n-2)/2+1=28,求得的n值取上整即可。也就是(n-1)(n-2)=54,n取上整可得n=9</p>
</blockquote>
<blockquote>
<p>至少有 9 个顶点</p>
<p>全连通图的定点n 和边数 m 满足：</p>
<p>m = n(n-1)/2</p>
<p>那么边 m = 22 时, 图 G:</p>
<p>n(n-1)/2 &gt;= 22</p>
<p>n &gt;= 8</p>
<p>而且，当n = 7 时，全连通图 G' 的边数m = 21</p>
<p>当我们把第 8 个定点加上来，必然还要再在这个定点和上面7个定点相连，以便构成第 22 边，8个顶点不足以构成22边非连通图。</p>
<p>加上第 9 个定点后，可以在 (8, 9) 之间构成第22边，或者，选择 8, 或 9 作为孤立点，构成非连通图</p>
<p>至少有 9 个顶点</p>
<p><strong>扩展资料</strong></p>
<p>任意一条边都代表u连v以及v连u。无向图是相对于有向图来说明的，就是说每条边都是双向边，而有向图每条边都是单向边，也就是说只能由一个点指向另一个点。</p>
<p>证明:</p>
<p>假设有8个顶点,则8个顶点的无向图最多有28条边且该图为连通图</p>
<p>连通无向图构成条件:边=顶点数*(顶点数-1)/2</p>
<p>顶点数&gt;=1，所以该函数存在单调递增的单值反函数</p>
<p>所以边与顶点为增函数关系</p>
<p>所以28个条边的连通无向图顶点数最少为8个</p>
<p>所以28条边的非连通无向图为9个(加入一个孤立点)</p>
</blockquote>
<p>2、已知一无向图G=（V，E），其中V={a,b,c,d,e}, E={(a,b),(a,d),(a,c),(d,c),(b,e)}现用某一种图遍历方法从顶点a开始遍历图，得到的序列为abecd，则采用的是（深度优先）遍历方法</p>
<p>3、求图的最小生成树有两种算法，其中（克鲁斯卡尔）算法适合于求稀疏图的最小生成树</p>
<blockquote>
<p>求图的最小生成树有两种算法</p>
<p>克鲁斯卡尔算法适合于求边稀疏的图的最小生成树，普里姆算法适合稠密图</p>
</blockquote>
<p>4、求从某源点到其余各顶点的Dijkstra算法，当图的顶点数为10，用邻接矩阵表示图时计算时间约为10ms，则当图的顶点数为40时，计算时间为多少ms?</p>
<blockquote>
<p>dijkstra算法的时间复杂度是O(n²),<br>
不妨设为kn²,其中次数小于1的项忽略<br>
k(10×10）=10ms<br>
那么k(40×40）=16[k×（10×10）]=160ms</p>
</blockquote>
<p>5、设有向图有n个顶点和e条边，采用邻接表作为其存储表示，在进行拓扑排序时，总的计算时间为（）。</p>
<blockquote>
<p><strong>标准答案：O(n+e)</strong></p>
</blockquote>
<p>6、</p>
<blockquote>
<p>若查找每个记录的概率均等，则在具有n个记录的连续顺序文件中采用顺序查找法查找一个记录，其平均查找长度ASL为（n+1）/2</p>
</blockquote>
<p>7、</p>
<table>
<thead>
<tr>
<th>序号</th>
<th>0</th>
<th>1</th>
<th>2</th>
<th>3</th>
<th>4</th>
<th>5</th>
<th>6</th>
<th>7</th>
<th>8</th>
<th>9</th>
<th>10</th>
</tr>
</thead>
<tbody>
<tr>
<td>关键码</td>
<td>8</td>
<td>11</td>
<td>15</td>
<td>19</td>
<td>25</td>
<td>26</td>
<td>30</td>
<td>33</td>
<td>42</td>
<td>48</td>
<td>50</td>
</tr>
<tr>
<td>1</td>
<td>low</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td>mid</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td>high</td>
</tr>
<tr>
<td>2</td>
<td>low</td>
<td></td>
<td>mid</td>
<td></td>
<td>high</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>3 找到8</td>
<td>low mid</td>
<td>high</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>1</td>
<td>low</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td>mid</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td>high</td>
</tr>
<tr>
<td>2</td>
<td>low</td>
<td></td>
<td>mid</td>
<td></td>
<td>high</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>3</td>
<td></td>
<td></td>
<td></td>
<td>low mid</td>
<td>high</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>4 找不到20</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td>low mid high</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody>
</table>
<p>8、</p>
<blockquote>
<p>https://wenku.baidu.com/view/83eb2a71a417866fb84a8ecf.html</p>
<p>题目给出，空树的高度是-1  所以是F(h+3)</p>
</blockquote>
<figure data-type="image" tabindex="17"><img src="https://i.loli.net/2021/09/28/FLzDk3ZpQqtjglN.png" alt="image-20210616154926791" loading="lazy"></figure>
<figure data-type="image" tabindex="18"><img src="https://i.loli.net/2021/09/28/9TZaALkrcvh8VuR.png" alt="image-20210616155553746" loading="lazy"></figure>
<p>9、</p>
<p>注意：求第三个元素，但要求从0开始计数，所以是第四个</p>
<table>
<thead>
<tr>
<th>序号</th>
<th>0</th>
<th>1</th>
<th>2</th>
<th>3</th>
<th>4</th>
<th>5</th>
<th>6</th>
<th>7</th>
<th>8</th>
<th>9</th>
</tr>
</thead>
<tbody>
<tr>
<td>关键码</td>
<td>98</td>
<td>36</td>
<td>19</td>
<td>5</td>
<td>47</td>
<td>23</td>
<td>1</td>
<td>8</td>
<td>10</td>
<td>7</td>
</tr>
<tr>
<td>d=5</td>
<td>23</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td>98</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td>1</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td>36</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td>8</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td>19</td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
<td>5</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td>10</td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td>7</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td>47</td>
</tr>
</tbody>
</table>
<p>10、在对一组记录(54,38,106,21,15,72,60,45,83)进行直接插入排序时,当把第7个记录60插入到有序表时,为寻找插入位置需比较 (3) 次</p>
<blockquote>
<p>在插入第7个数，说明前面的数字已经有序了。</p>
<p>即数字为15--- 21---38---54----72---106---60---45---83</p>
<p>现在对第7个数字60进行插入，需要向前找到插入点。依次比较    106,72,54   最后插入在54后面。</p>
<p>所以比较3次。</p>
</blockquote>
<figure data-type="image" tabindex="19"><img src="https://i.loli.net/2021/09/28/eX1973FJhuIkGSm.png" alt="image-20210613031659158" loading="lazy"></figure>
<h4 id="四-简答题">四、简答题</h4>
<h5 id="1-b-树的插入-删除">1、B-树的插入、删除</h5>
<figure data-type="image" tabindex="20"><img src="https://i.loli.net/2021/09/28/BaFxwK9buPqYjUT.png" alt="image-20210616180731708" loading="lazy"></figure>
<figure data-type="image" tabindex="21"><img src="https://i.loli.net/2021/09/28/uCPlhJjoWz8YIVO.png" alt="image-20210616180841980" loading="lazy"></figure>
<h5 id="2-有向图邻接表最短路径">2、有向图+邻接表+最短路径</h5>
<p>①有向图的邻接表</p>
<p>②弗洛伊德（Floyd）算法</p>
<p>第一次：长度为1</p>
<table>
<thead>
<tr>
<th></th>
<th>A</th>
<th>B</th>
<th>C</th>
<th>D</th>
<th>E</th>
</tr>
</thead>
<tbody>
<tr>
<td>A</td>
<td>0</td>
<td>10</td>
<td>20</td>
<td></td>
<td></td>
</tr>
<tr>
<td>B</td>
<td></td>
<td>0</td>
<td>20</td>
<td>45</td>
<td></td>
</tr>
<tr>
<td>C</td>
<td>40</td>
<td></td>
<td>0</td>
<td>20</td>
<td>40</td>
</tr>
<tr>
<td>D</td>
<td>10</td>
<td>20</td>
<td>25</td>
<td>0</td>
<td></td>
</tr>
<tr>
<td>E</td>
<td></td>
<td></td>
<td>60</td>
<td>50</td>
<td>0</td>
</tr>
</tbody>
</table>
<p>第二次：长度为2</p>
<table>
<thead>
<tr>
<th></th>
<th>A</th>
<th>B</th>
<th>C</th>
<th>D</th>
<th>E</th>
</tr>
</thead>
<tbody>
<tr>
<td>A</td>
<td>0</td>
<td>10</td>
<td>20</td>
<td>40</td>
<td>60</td>
</tr>
<tr>
<td>B</td>
<td>55</td>
<td>0</td>
<td>20</td>
<td>40</td>
<td>60</td>
</tr>
<tr>
<td>C</td>
<td>30</td>
<td>40</td>
<td>0</td>
<td>20</td>
<td>40</td>
</tr>
<tr>
<td>D</td>
<td>10</td>
<td>20</td>
<td>25</td>
<td>0</td>
<td>65</td>
</tr>
<tr>
<td>E</td>
<td>60</td>
<td>70</td>
<td>60</td>
<td>50</td>
<td>0</td>
</tr>
</tbody>
</table>
<p>第三次：长度为3</p>
<table>
<thead>
<tr>
<th></th>
<th>A</th>
<th>B</th>
<th>C</th>
<th>D</th>
<th>E</th>
<th>求和</th>
</tr>
</thead>
<tbody>
<tr>
<td>A</td>
<td>0</td>
<td>10</td>
<td>20</td>
<td>40</td>
<td>60</td>
<td>130</td>
</tr>
<tr>
<td>B</td>
<td>50</td>
<td>0</td>
<td>20</td>
<td>40</td>
<td>60</td>
<td>170</td>
</tr>
<tr>
<td>C</td>
<td>30</td>
<td>40</td>
<td>0</td>
<td>20</td>
<td>40</td>
<td>130</td>
</tr>
<tr>
<td>D</td>
<td>10</td>
<td>20</td>
<td>25</td>
<td>0</td>
<td>65</td>
<td>120</td>
</tr>
<tr>
<td>E</td>
<td>60</td>
<td>70</td>
<td>60</td>
<td>50</td>
<td>0</td>
<td>240</td>
</tr>
</tbody>
</table>
<p>③最短路径</p>
<table>
<thead>
<tr>
<th></th>
<th>A</th>
<th>B</th>
<th>C</th>
<th>D</th>
<th>E</th>
<th>行求和</th>
<th>行列求和</th>
</tr>
</thead>
<tbody>
<tr>
<td>A</td>
<td>0</td>
<td>10</td>
<td>20</td>
<td>40</td>
<td>60</td>
<td>130</td>
<td>280</td>
</tr>
<tr>
<td>B</td>
<td>50</td>
<td>0</td>
<td>20</td>
<td>40</td>
<td>60</td>
<td>170</td>
<td>310</td>
</tr>
<tr>
<td>C</td>
<td>30</td>
<td>40</td>
<td>0</td>
<td>20</td>
<td>40</td>
<td>130</td>
<td>255</td>
</tr>
<tr>
<td>D</td>
<td>10</td>
<td>20</td>
<td>25</td>
<td>0</td>
<td>65</td>
<td>120</td>
<td>270</td>
</tr>
<tr>
<td>E</td>
<td>60</td>
<td>70</td>
<td>60</td>
<td>50</td>
<td>0</td>
<td>240</td>
<td>465</td>
</tr>
<tr>
<td>列求和</td>
<td>150</td>
<td>140</td>
<td>125</td>
<td>150</td>
<td>225</td>
<td></td>
<td></td>
</tr>
</tbody>
</table>
<h5 id="3-各类排序方法">3、各类排序方法</h5>
<p>基数排序的答案出错</p>
<h4 id="五-算法题">五、算法题</h4>
<h5 id="1-递归函数">1、递归函数</h5>
<p>注意肯定是递归函数，答案里一定会用到函数名</p>
<h5 id="2-有向图的遍历">2、有向图的遍历</h5>
<h5 id="3-折半查找">3、折半查找</h5>
<h4 id="六-算法设计题">六、算法设计题</h4>
<h5 id="1-有向图的遍历">1、有向图的遍历</h5>
<p>根据前面的题目，可以很容易设计出来</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[数据结构1 复习笔记]]></title>
        <id>https://amadeus075.github.io/post/shu-ju-jie-gou-1-fu-xi-bi-ji/</id>
        <link href="https://amadeus075.github.io/post/shu-ju-jie-gou-1-fu-xi-bi-ji/">
        </link>
        <updated>2021-09-27T13:10:57.000Z</updated>
        <content type="html"><![CDATA[<h1 id="食用说明">食用说明</h1>
<p>有些题目是很久以前写的，当时可能做错了，现在忘记是哪些做错了。</p>
<p>总之，复习时自己亲手写一遍，对照一下答案，比粗略的看一遍要好很多。</p>
<p>参考：https://www.cnblogs.com/aoru45/p/10429897.html</p>
<h1 id="一些好的练习题">一些好的练习题</h1>
<p>感觉看些填空选择就可以了</p>
<p>算法设计还是看课本的题目</p>
<p>在第五章应用题看见了考试原题</p>
<p><strong>①选择、填空、判断	有答案</strong></p>
<p>https://wenku.baidu.com/u/songguangya2?from=wenku		主页</p>
<p>已做：练习01、练习02(算法设计没看完)、练习03(算法设计没看)、习题04(无算法设计	选择填空难点较多)</p>
<p>难点：上下三角矩阵、字符串的字符(从1开始)、对称矩阵</p>
<p><strong>②选择、应用	有解析</strong></p>
<p>https://blog.csdn.net/m0_37243410/category_7048866.html		主页</p>
<p>选择、填空、简答已做		算法题没做</p>
<p>next数组：右移一位，左边补-1，然后全体+1</p>
<p><strong>③数据结构专项精讲课程讲义	有答案</strong></p>
<p>https://wenku.baidu.com/view/c48216b9b8f3f90f76c66137ee06eff9aef849bf.html</p>
<p><strong>④数据结构(C++版)课后答案_(王红梅)第2、3章	有解析</strong></p>
<p>https://wenku.baidu.com/view/0cabf3ea81c758f5f61f677a.html	主页</p>
<p>填空、选择已做</p>
<p><strong>⑤整版)非常实用的数据结构知识点总结</strong></p>
<p>https://wenku.baidu.com/view/0b36c2144128915f804d2b160b4e767f5acf80b2.html</p>
<h1 id="上海大学2015~2016数据结构一">上海大学2015~2016数据结构(一)</h1>
<h2 id="一-填空">一、填空</h2>
<p>1、在以HL为表头指针的带表头附加结点的单链表和循环单链表中，判断链表为空的条件分别为<strong>HL→next =NULL；和 HL=HL→next；</strong>。</p>
<p>2、调整得到的最小堆序列的最后一个元素为（<strong>78</strong>）</p>
<blockquote>
<p>参考：https://blog.csdn.net/hrn1216/article/details/51465270</p>
</blockquote>
<p>3、对于一个长读为n的顺序存储的线性表，在表头插入元素的时间复杂度为（<strong>O(n)</strong> ）。</p>
<blockquote>
<p>对于一个长度为n的顺序存储的线性表，在表头插入元素的时间复杂度为0(n)，在表尾插入元素的时间复杂度为0(1)。</p>
<p>顺序存储的线性表，是用数组实现的。在表尾插入元素，只要直接在表尾增加一个元素，并修改表的元素个数（加1）。所以其复杂度为0(1)。</p>
</blockquote>
<p>拓展：</p>
<blockquote>
<p>对于一个长度为n的单链存储的线性表，在表头插入元素的时间复杂度为______O(1）______，在表尾插入元素的时间复杂度为______O(n)______。</p>
<p>表头插入时间复杂度O(1），因为不需用移动元素，常数时间完成操作；表尾插入复杂度O(n)，因为每次操作都需用把指针先移动到表尾，需用n次移动。</p>
</blockquote>
<p>4、设栈S和队列Q的初始状态均为空，元素abcdefg依次进入栈S。若每个元素出栈后立即进入队列Q，且7个元素出队的顺序是bdcfeag，则栈S的容量至少是（<strong>3</strong>）</p>
<blockquote>
<p>栈后入先出的特点。队列先入先出，即队列也是bdcfeag</p>
<p>开始a先入栈，然后b入栈，然后b出栈，队列b 然后c,d依次入栈，然后d,c依次出栈，队列bcd 然后e,f依次入栈，然后f e 出栈队列bdcfe</p>
<p>a出栈，g进栈g出栈；</p>
<p>栈最多时为3 即 acd 、aef时栈深度为3</p>
</blockquote>
<p>5、一个栈的入栈序列为1,2,3,...,n ，其出栈序列是 p1, p2, p3, … pn 。若p2 = 3，则 p3 可能取值的个数是（<strong>n-1</strong>）</p>
<figure data-type="image" tabindex="1"><a href="https://imgtu.com/i/4R3VPg"><img src="https://z3.ax1x.com/2021/09/27/4R3VPg.png" alt="4R3VPg.png" loading="lazy"></a></figure>
<p>6、设以数组Q.elems[maxSize]存储循环队列的元素，同时以Q.rear和Q.length分别指示循环队列中的队尾位置和队列中所含元素的个数</p>
<pre><code class="language-c++">Q.length==0		//队空的条件
Q.length==maxSize	//队满的条件
//入队
Q.rear=(Q.rear+1)%maxSize;// 移动指针
Q.elems[Q.rear]=x;// 入队元素
Q.length++;// 队列长度加1
</code></pre>
<blockquote>
<p>参考：https://blog.csdn.net/cnds123321/article/details/106740109</p>
</blockquote>
<p>7、一维数组的逻辑结构是(线性结构)，存储结构是(顺序结构)；对于二维或多维数组，分(以行为主序)和(以列为主序)两种不同存储方式。</p>
<blockquote>
<p>一维数组是 顺序存储结构 二维数组或多维数组 行优先或者列优先 逻辑结构 线性结构</p>
</blockquote>
<p>8、一个右子树为空的二叉树在后序线索化后，其空指针域的个数为：<strong>2</strong></p>
<p>拓展：</p>
<blockquote>
<p>一棵左子树为空的二叉树在先序线索化后，其中空的链域的个数是___D___。</p>
<p>A．不确定<br>
B．0<br>
C．1<br>
D．2</p>
<p>解释：</p>
<p>左子树为空的二叉树的根结点的左线索为空(无前驱)，先序序列的最后结点的右线索为空(无后继)，共2个空链域。</p>
</blockquote>
<p>9、设n 为哈夫曼树的叶子结点数目，则该哈夫曼树共有（<strong>2n-1</strong>）个结点。</p>
<blockquote>
<p>首先，哈夫曼树是一个二叉树；第二点，哈弗曼树的度只有两种情况，一是只有两个度的结点，二是没有度的结点，即叶子结点。设两个度的节点数为n2, 已知叶子结点为n，总节点数减1等于分支数，可知n2+n-1=2*n2</p>
</blockquote>
<p>————————————————————————————————————————————————</p>
<blockquote>
<p>无论哈夫曼树是几叉，其特点是一致的（假设为m叉），即树中只存在度为0的结点（即叶结点）和度为m的结点。不妨设度为0的结点个数为x，度为m的结点个数为y，则存在一个等式x+y=my+1，即x=(m-1)y+1，x+y是树的总结点个数。</p>
<p>就这道题来说，假设哈夫曼树是二叉的话，则度为0的结点个数为N，度为2的结点个数为N-1，则结点总数为2N-1。</p>
</blockquote>
<h2 id="二-单选题">二、单选题</h2>
<p>1、广义表A=(a),则表尾为	(<strong>C	空表</strong>)</p>
<p>2、若某线性表最常用的操作是存取任一指定序号的元素和在最后进行插入和删除运算，则利用( <strong>A	顺序表</strong>)存储方式最节省时间</p>
<blockquote>
<p>“存取任一指定序号”最好的方法是实现“随机存取”，则可采用顺序表。并且，因为插入和删除操作都是在最后进行的，所以无需大量移动数据元素，选项A是最合适的。</p>
</blockquote>
<p>3、假设栈初始为空，将中缀表达式<strong>a/b+(c*d-e*f)/g</strong>转化为等价的狗追表达式的过程中，当扫描到f时，栈中的元素依次是（<strong>B	+（-</strong>*）</p>
<blockquote>
<p>参考：https://blog.csdn.net/qq_22073849/article/details/78416135</p>
</blockquote>
<p>4、已知循环队列存储在一维数组A[0…n-1]，且队列非空时，front和rear分别指向队头元素和队尾元素。若初始时队列为空，且要求第一个进入队列的元素存储在A[0]处，则初始时front和rear的值分别是（<strong>B. 0，n-1</strong> ）</p>
<blockquote>
<p>参考：https://blog.csdn.net/qq_22073849/article/details/78362502</p>
<p>https://www.nowcoder.com/questionTerminal/1d83ef24b318444e81dd426c657bd61c</p>
</blockquote>
<blockquote>
<p>插入时，队头指针不变，队尾指针后移一位。该题约定队列非空时 front  和 rear 分别指向队头和队尾元素，即插入第一个元素在下标为0的位置后，队头队尾指针皆指向A[0]，此时可以反推出插入前，队头指针仍旧指向下标0，而队尾指针应指向前一位，也就是下标n-1的位置。注意，这道题的约定与大多数题约定队列为空时front=rear=0是不一样的约定，都是根据题意解题。</p>
</blockquote>
<p>5、<code>设有一个10阶的下三角矩阵A（包括对角线），按照从上到下、从左到右的顺序存储到连续的55个存储单元中，每个数组元素占1个字节的存储空间，则A[5][4]地址与A[0][0]的地址之差为（ B 19 ）。</code></p>
<figure data-type="image" tabindex="2"><a href="https://imgtu.com/i/4R3e2j"><img src="https://z3.ax1x.com/2021/09/27/4R3e2j.png" alt="4R3e2j.png" loading="lazy"></a></figure>
<p>6、广义表A=(（x, (a ,b)), (x,(a,b),y)), 则运算Head(Head(Tail(A)))结果为(  <strong>A x</strong> )</p>
<blockquote>
<p>题目中给出的：</p>
<p>A=(x, (a ,b) ), (x, (a,b)  ,y) )  少了一个括号配对，应该为：<strong>A=( （x, (a,b)）,(x, (a,b), y)  )</strong></p>
<p>Head( Head( Tail(A) ) )  ) 多了一个括号，应该改为：<strong>Head( Head( Tail(A) ) )</strong></p>
<p>由内到外依次运算：Head广义表的第一个元素，Tail取广义表除了第一个元素外的其他元素</p>
<ol>
<li>Tail(A)=（x, (a,b), y）</li>
<li>Head(Tail(A))=(x)</li>
<li>Head(Head(Tail(A)))=(x)</li>
</ol>
</blockquote>
<p>7、函数substr(&quot;DATASTURCTURE&quot;,5,9)的返回值为( <strong>A STRURCTURE</strong> )</p>
<blockquote>
<p>substr(&quot;DATASTURCTURE&quot;,5,9)<br>
这个函数的意思是从字符串“DATASTURCTURE”的第五个字符S开始，截取后面的9个字符。<br>
所以为：<br>
STRURCTURE</p>
</blockquote>
<p>8、C 	26</p>
<p>9、一棵完全二叉树上有1001个结点，其中叶子结点的个数是（<strong>A 501</strong>）</p>
<blockquote>
<figure data-type="image" tabindex="3"><a href="https://imgtu.com/i/4R3ZGQ"><img src="https://z3.ax1x.com/2021/09/27/4R3ZGQ.png" alt="4R3ZGQ.png" loading="lazy"></a></figure>
</blockquote>
<p>10、设n、m为一棵二叉树上的两个结点，在中序遍历时，n在m前的条件是(<strong>C．n在m左方</strong> )。</p>
<blockquote>
<p>中序遍历时，先访问左子树，再访问根结点。n在m前，则n必须在m的左子树中。因此本题答案为C。</p>
</blockquote>
<blockquote>
<p>中序遍历为左根右，所以n一定要在m左边</p>
</blockquote>
<blockquote>
<p>参考：https://blog.csdn.net/qq_43839907/article/details/103359858</p>
</blockquote>
<h2 id="三-是非题">三、是非题</h2>
<p>1、线性表采用链表存储时，查找第i个元素的时间与i的值无关	(<strong>×</strong>)</p>
<blockquote>
<p>线性链表的存储是非顺序存储的，访问第i个元素是需要从第一个元素开始一个一个的来寻找，所以跟i值成正比，线性表在顺序存储时，是顺序存储的，访问第i个元素是可以直接访问到，时间复杂度为o(1)，与i无关</p>
</blockquote>
<p>2、非空的双向循环链表中任何结点的前驱指针均不为空。（<strong>√</strong> ）</p>
<blockquote>
<p>是正确的。 只要是循环链表，任一一个节点的前驱指针和后继指针都不会为空。 双向循环链表是循环链表的一种，所以也适用于这个规律。<br>
原因如下：<br>
1 对于单向链表，是从第一个节点开始，到最后一个节点结束，其指向为<br>
P1-&gt;P2-&gt;P3-&gt;...-&gt;Pn<br>
第一个节点P1的前驱指针和最后一个节点Pn的后继指针为空。<br>
2 对于循环链表， 会将最后一个节点指向第一个节点，构成循环：<br>
P1-&gt;P2-&gt;P3-&gt;...-&gt;Pn-&gt;P1<br>
而双向循环链表则是每个节点两个指针，分别指向上一个和下一个：<br>
P1&lt;-&gt;P2&lt;-&gt;P3&lt;-&gt;...&lt;-&gt;Pn&lt;-&gt;P1<br>
从这个结构可以看出， 每一个节点的前驱和后继都不可能为空， 当只有一个节点的时候，前驱和后继都是自身。</p>
</blockquote>
<p>3、某队列允许在其两端进行入队操作，但仅允许在一端进行出队操作，则不可能得到的顺序是dbcae( √ )</p>
<blockquote>
<p>正确答案是 C</p>
<p>本题的队列实际上是一个输出受限的双端队列。A操作：a左入（或右入）、b左入、c右入、d右入、e右入。B操作：a左入（或右入）、b左入、c右入、d左入、e右入。D操作：a左入（或右入）、b左入、c左入、d右入、e左入。C操作：a左入（或右入）、b右入、因d未出，此时只能进队，c怎么进都不可能在b和a之间。</p>
<p>【另解】初始时队列为空，第1个元素a左入（或右入），而第2个元素b无论是左入还是右入都必与a相邻，而选项D中a与b不相邻，不合题意。</p>
</blockquote>
<blockquote>
<p>[解析] 考查受限的双端队列的出队序列。<br>
A．可由左入，左入，右入，右入，右入得到；<br>
B．可由左入，左入，右入，左入，右入得到；<br>
D．可由左入，左入，左入，右入，左入得到；<br>
所以不可能得到C。</p>
</blockquote>
<p>4、用不带头结点的单链表存储队列时，队头指针指向队头结点，队尾指针指向队尾结点，则在进行出队操作时只需要修改队头指针(× )。</p>
<blockquote>
<p>如果当前队列中仅有一个元素，则删除它时队头、队尾指针都需要修改。</p>
</blockquote>
<p>5、稀疏矩阵压缩存储后，必然会失去随机存取功能（√）</p>
<blockquote>
<p>稀疏矩阵压缩存储后，必会失去随机存取功能。稀疏矩阵在采用压缩存储后将会失去随机存储的功能。因为在这种矩阵中，非零元素的分布是没有规律的，为了压缩存储，就将每一个非零元素的值和它所在的行、列号做为一个结点存放在一起，这样的结点组成的线性表中叫三元组表，它已不是简单的向量，所以无法用下标直接存取矩阵中的元素。</p>
</blockquote>
<blockquote>
<p>稀疏矩阵用三元组存储，已经不能用简单的下标来实现访问，所以已经失去了随机访问的功能</p>
</blockquote>
<p>6、广义表的组成元素可以是不同形式的元素（√）</p>
<p>7、一个广义表的表头为空表,则此广义表亦为空表（×）</p>
<blockquote>
<p>举一个简单的反例就可说明为什么了,例如广义表L = { { },1,2 },该广义表的长度为3,深度为2,表头head(L) = { },tail(L) = {1,2},可以看出表头为{ },它是一个空表,但表L并不是空表的呀.</p>
</blockquote>
<p>8、对一棵二叉树进行层次遍历时,应借助于一个队列(√)</p>
<blockquote>
<p>应该借助于队列，二叉树的先序，后序，中序的非递归遍历才需要栈</p>
</blockquote>
<blockquote>
<p>由层次遍历的定义可知，在进行层次遍历时，对一层的结点访问完后，在按照他们的访问次序依次对各个节点的左右孩子顺序访问，这样一层一层的进行，先遇到的结点先访问，这与队列的操作原则比较吻合，因此在进行层次遍历时，可设置一个队列结构，遍历从二叉树的根节点开始，首先将根节点指针入队列，依次执行下面操作：</p>
<p>1）队列不空，出队列，去队头元素</p>
<p>2）访问该元素所指结点</p>
<p>3）若该元素所指结点的左右孩子结点非空，则该元素所指结点的左孩子指针和右孩子指针顺序入队。</p>
</blockquote>
<p>9、二叉树中序线索化后，不存在空指针域（×）</p>
<blockquote>
<p>非空二叉树中序遍历第一个结点无前驱，最后一个结点无后继，这两个结点的前驱线索和后继线索为空指针。</p>
</blockquote>
<p>10、完全二叉树中，若一个结点没有左孩子，则它必是树叶（√）</p>
<blockquote>
<p>完全二叉树如果没有左结点，则一定没有右结点，即没有左孩子，它就一定是树叶。</p>
</blockquote>
<blockquote>
<p>参考：https://blog.csdn.net/weixin_46678290/article/details/105408072</p>
</blockquote>
<h2 id="四-应用题">四、应用题</h2>
<p>1、KMP算法，计算失效函数值，填写KMP算法每一轮的匹配过程</p>
<blockquote>
<p>参考：https://blog.csdn.net/lemon_sun/article/details/37655509</p>
</blockquote>
<p>2、已知频率，构造并画出哈夫曼树，求哈夫曼编码</p>
<h2 id="五-问答题">五、问答题</h2>
<p>1、已知一棵二叉树的层次序列、中序序列，画出该二叉树，写出后序序列，求高度</p>
<blockquote>
<p>参考：https://bbs.csdn.net/topics/70107860</p>
</blockquote>
<p>2、利用栈S1和S2模拟一个队列，完成入队、出队、判空操作</p>
<blockquote>
<p>参考：https://blog.csdn.net/fan9511/article/details/38015891</p>
<p>https://blog.csdn.net/weixin_44279771/article/details/107860898</p>
</blockquote>
<h2 id="六-算法填空题">六、算法填空题</h2>
<p>1、将不带头结点的非空单链表A分解成两个单链表A和B</p>
<blockquote>
<p>参考：https://blog.csdn.net/qq_43648337/article/details/107494392</p>
</blockquote>
<p>2、在二叉树的二叉链表类模板中，实现非递归中序遍历二叉树</p>
<blockquote>
<p>参考：http://c.biancheng.net/view/3389.html</p>
<p>https://blog.csdn.net/qq_33060405/article/details/78505347</p>
</blockquote>
<h2 id="七-算法设计题">七、算法设计题</h2>
<p>1、在单链表类中增加一个用于判断带头结点的单链表中数据元素是否是递增的成员函数</p>
<h1 id="上海大学2014~2015数据结构一">上海大学2014~2015数据结构(一)</h1>
<h2 id="一-填空题">一、填空题</h2>
<p>1、带头结点的循环链表 L 中只有一个元素结点的条件是（<strong>head-&gt;next-&gt;next=head</strong>） 。</p>
<p>拓展：</p>
<blockquote>
<figure data-type="image" tabindex="4"><a href="https://imgtu.com/i/4R3AIS"><img src="https://z3.ax1x.com/2021/09/27/4R3AIS.png" alt="4R3AIS.png" loading="lazy"></a></figure>
</blockquote>
<p>2、在顺序表中访问任意一结点的时间复杂度均为（<strong>O（1）</strong>），因此，顺序表也称为（<strong>随机存取</strong>）的数据结构</p>
<p>3、设栈S和队列Q的初始状态为空。元素a、b、c、d、e、f依次通过栈S，并且一个元素出栈后即进入队列Q，若出队的顺序为b、d、c、f、e、a，则栈S的容量至少应该为（<strong>3</strong>）</p>
<blockquote>
<p>[分析] 由于队列是先进先出线性表，队列Q的出队顺序为b、d、c、f、e、a，则入队顺序必定也是b、d、c、f、e、a，这一顺序就是栈S的出栈顺序。又由于入栈顺序为a、b、c、d、e、f，因此入栈和出栈顺序是：a、b入栈，b出栈，c、d入栈，d、c出栈、e、f入栈，f、e、a出栈，因此栈中驻留元素最多是3个，因此栈S的容量至少应该为3。</p>
</blockquote>
<p>5、假设一棵二叉树的结点个数为1638，则它的最小高度是（<strong>11</strong> ）</p>
<blockquote>
<p>高度最少的时候，就是除了叶子结点外，其他的每层都是满节点，即满二叉树。满二叉数节点和高度的关系有：节点数=2的高度次方-1，由此可以推算出，当节点数是1638的时候，该二叉树的最小高度是11层</p>
</blockquote>
<p>6、在一个最小堆中，所有结点中的最大值一定在（<strong>叶子</strong>）结点中</p>
<p>拓展：</p>
<blockquote>
<p><img src="%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84(1)%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0.assets/image-20210310155312804.png" alt="image-20210310155312804" loading="lazy"><a href="https://imgtu.com/i/4R3ka8"><img src="https://z3.ax1x.com/2021/09/27/4R3ka8.png" alt="4R3ka8.png" loading="lazy"></a></p>
</blockquote>
<p>7、广义表运算式 Tail(((a,b),(c,d)))的操作结果是（  <strong>((c,d))</strong>  ）</p>
<blockquote>
<p>表尾是指除了表头以外所有原子和子表组成的新表。</p>
<p>原表：((a,b),(c,d))</p>
<p>表头：(a,b)</p>
<p>表尾：((c,d))  // 表尾是新表所以多一层括号</p>
</blockquote>
<p>8、已知串S=‘aaab’,其Next数组值为（ <strong>0 1 2 3</strong> ）</p>
<blockquote>
<p>序号：1 2 3 4<br>
数组：a a a b<br>
next： 0 1 2 3</p>
<p>注意上边序号、数组和next的对应关系</p>
<p>求next值的过程：<br>
前两位：next数组值前两位一定为01，即aaab中的前两位aa对应01，如上表中next第1，2位为0和1.其实这就可以选出答案了.</p>
<p>第三位：3a前面是2a（2a表示序号为2的a），2a的next数组值为1，找到序号为1的字符, 即1a,将2a和1a相比，两者相同，都是a，则3a的next值为2a的next值加1，即2；</p>
<p>第四位：4b前3a的next为2，找到序号为2的字符, 即2a, 将3a与2a相比，二者相同，则其next值为3a的next加1，为3.<br>
结果为0123</p>
</blockquote>
<blockquote>
<p>KMP算法的关键是计算一个next数组，也叫做失效函数</p>
</blockquote>
<p>9、求哈夫曼树的带权路径长度</p>
<blockquote>
<p>参考：</p>
<p>https://blog.csdn.net/qq_33369979/article/details/100060262</p>
<p>https://blog.csdn.net/xueba8/article/details/78477892</p>
</blockquote>
<p>10、数据结构主要研讨数据的<strong>逻辑结构</strong>和<strong>物理结构</strong>，以及它们之间的<strong>相互关系</strong>，并对这种结构定义相应<strong>操作/运算</strong>，设计出相应的<strong>算法</strong>。</p>
<h2 id="二-选择题">二、选择题</h2>
<p>1、某线性表中最常用的操作是在最后一个元素之后插入一个元素和删除第一个元素，则采用（<strong>A</strong> <strong>仅有尾指针的单循环链表</strong>）存储方式最节省运算时间。</p>
<blockquote>
<p>仅有尾指针的单循环链表，可以非常方便地找到尾结点，尾结点后面的第一个结点往往是头结点，头结点的下一个结点就是第线性表的第一个结点。对最后一个元素和第一个元素操作对带尾指针的单循环链表是非常方便的。</p>
</blockquote>
<p>2、在双向链表中，在p结点之后插入结点q的操作是( <strong>B	q-＞next=p-＞next；p-＞next-＞prior=q；p-＞next=q；q-＞prior=p；</strong> )。</p>
<blockquote>
<p>[解析] 在链表中，对指针的修改必须保持线性表的逻辑关系，否则，将违背线性表的逻辑特征。<br>
本题主要考查双向链表的插入算法中的指针的变化过程。虽然4个选项中的语句相同，但顺序不同，根据双向链表的结构特点可知选项B的操作顺序是正确的，其他3个选项的指针修改顺序不能完成在<em>p结点之后插入结点</em>q的操作。</p>
</blockquote>
<p>3、为了增加内存空间的利用率和减少溢出的可能性，由两个栈共享一片连续的内存空间时，应将两个栈的栈底分别设在这片内存空间的两端。如此只有当( <strong>C 两个栈的栈顶在栈空间的某一位置相遇</strong> )时，才产生溢出。</p>
<blockquote>
<p>[解析] 在一个程序中需要同时使用具有相同成分类型的两个栈时，为避免造成存储空间的浪费，应采用双进栈操作。为两个栈共同开辟一个连续的存储空间，一个栈的栈底为该空间的始端，另一个栈的栈底为该存储空间的末端。当元素进栈时都从此存储空间的两端向中间“延伸”。只有当两个栈的栈顶在该存储空间的某处相遇时，才会发生上溢。</p>
</blockquote>
<p>4、用不带头结点的单链表存储队列时，其队头指针指向队头结点，其队尾指针指向队尾结点，则在进行删除操作时(  <strong>D</strong> <strong>队头、队尾指针都可能要修改</strong> )。</p>
<blockquote>
<p>如果当前队列中仅有一个元素，则删除它时队头、队尾指针都需要修改。</p>
<p>因为当队列中只有一个元素时，删除此元素后要将队列置空，此时要修改队尾指针，使尾指针与头指针相等（即Q.rear = Q.front）</p>
</blockquote>
<p>5、稀疏矩阵采用压缩存储的目的主要是为了 （<strong>C 节省存储空间</strong>）。</p>
<blockquote>
<p>对稀疏矩阵，目前还没有一个明确的定义，但是一般认为，稀疏矩阵是非零元素较零元素少，且分布没有一定规律的矩阵。在矩阵运算中和矩阵输入输出中，最方便的存储方式就是二维数组，对矩阵进行压缩不能简化矩阵运算，对输入输出也不能提供便利，而降低运算的时间复杂度主要与算法有关，一般对矩阵压缩后其运算的复杂度会增加。所以答案是节省存储空间。</p>
</blockquote>
<p>6、设有一个10阶的对称矩阵A，采用压缩存储方式，以行序为主存储，a1,1为第一元素，其存储地址为1，每个元素占一个地址空间，则a8,5的地址是（<strong>B  33</strong>）。</p>
<blockquote>
<p>[解析] 这里数组下标从1开始，只存储其下三角形元素，在a8,5的前面有7行，第1行有1个元素，第2行有2个元素，…，第7行有7个元素，这7行共有(1+7)×7/2=28个元素，在第8行中，a8,5的前面有4个元素，所以，a8,5前有28+4=32个元素，其地址为33。</p>
</blockquote>
<p>7、数据在计算机存储器内表示时，物理地址与逻辑地址不相同的，称之为（<strong>C	链式存储结构</strong>）</p>
<p>8、若一棵二叉树具有10个度为2的结点，5个度为1的结点，则二叉树的结点个数是(<strong>C 26</strong> )。</p>
<blockquote>
<p>拓展：</p>
<p>若一棵二叉树具有10个度为2的结点， 5个度为1的结点，则度为0的结点 （即叶子结点）个数是（39） 。</p>
<p>n=n0+n1+n2 	n=1+n1+2*n2 （n为结点总数，n0为度为0的结点数，n1为度为1的结点数，n2为度为2的结点数） 可以推出 n0=n2+1 因此，度为0的结点个数=10+1=11</p>
</blockquote>
<p>9、下列有关二叉树的说法中，正确的是( <strong>B．一棵二叉树的度可以小于2</strong> )。</p>
<blockquote>
<p>[解析]二叉树的定义为：二叉树是结点的有限集合，这个有限集合或者为空集，或者由一个根结点及两棵不相交的分别称做这个根的左子树和右子树的二叉树所构成，这里的左子树和右子树也符合二叉树的定义。由二叉树定义可得到这些信息：二叉树可以是空集，当二叉树为空集时，度为0；每个结点有两棵可以是空集的子树，当一棵子树为空，另一棵子树来为空时，该结点的度为1，都不为空时，度为2。由此可判断A、C、D是错误的，二叉树的度可以为0、1，结点的度也可以是0、1；选项B是正确的。</p>
</blockquote>
<p>10、一棵非空的二叉树的先序遍历序列与后序遍历序列正好相反，则该二叉树一定满足（<strong>C	只有一个叶子结点</strong>）</p>
<blockquote>
<p>之所以不能选AB，是因为题目中只交代了非空，</p>
<p>而如果该二叉树只有根节点，即满足了AB条件，</p>
<p>而显然此状态下，三种遍历顺序的结果都相同。</p>
<p>因此我们只能选择C</p>
<p>先序：根-&gt;左-&gt;右</p>
<p>后序：左-&gt;右-&gt;根</p>
<p>只有两个节点是，可以省略为：</p>
<p>先序：根-&gt;孩子</p>
<p>后序：孩子-&gt;根</p>
<p>因此选C</p>
</blockquote>
<h2 id="三-是非题-2">三、是非题</h2>
<p>1、线性表采用顺序存储结构时，可以进行较快的插入和删除。		（×）</p>
<blockquote>
<p>[解析] 在顺序表上做插入删除，将引起大量元素的移动。散列表也不便于删除，只有链接表既便于插入删除(因为只需要修改指针，不需要移动元素)，又能(通过指针域)反应元素之间的逻辑关系。</p>
</blockquote>
<p>2、单链表中取第i个元素的时间与i成正比。（√)</p>
<p>3、循环顺序队列不存在上溢问题	（×）</p>
<blockquote>
<p>​		<strong>① &quot;下溢&quot;现象</strong><br>
当队列为空时，做出队运算产生的溢出现象。“下溢”是正常现象，常用作程序控制转移的条件。<br>
　　<strong>② &quot;真上溢&quot;现象</strong><br>
当队列满时，做进栈运算产生空间溢出的现象。“真上溢”是一种出错状态，应设法避免。<br>
　　<strong>③ &quot;假上溢&quot;现象</strong><br>
　　由于入队和出队操作中，头尾指针只增加不减小，致使被删元素的空间永远无法重新利用。当队列中实际的元素个数远远小于向量空间的规模时，也可能由于尾指针已超越向量空间的上界而不能做入队操作。该现象称为&quot;假上溢&quot;现象。</p>
</blockquote>
<blockquote>
<p>参考：http://blog.sina.com.cn/s/blog_5b9734c501015wjp.html</p>
</blockquote>
<p>4、若输入序列为abcd，则通过一个栈可以输出cdab	（×）</p>
<p>5、若一个广义表的表头为空表,则此广义表一定不为空表	（×）	类似的题目</p>
<p>举一个简单的反例就可说明为什么了,例如广义表L = { { },1,2 },该广义表的长度为3,深度为2,表头head(L) = { },tail(L) = {1,2},可以看出表头为{ },它是一个空表,但表L并不是空表的呀.</p>
<p>6、一个稀疏矩阵 A m n 采用三元组形式表示，若把三元组中有关行下标与列下标的值互换，并把m和n的值互换，就完成了A mn 的转置运算。（×）</p>
<blockquote>
<p>行列互换，再按行排序</p>
</blockquote>
<p>7、数据元素是数据的最小单位。	（×）</p>
<blockquote>
<p>数据元素是数据的基本单位, 数据项是不可分割的最小单位<br>
数据项是构成数据元素的最小单位</p>
</blockquote>
<p>8、二叉树的存储结构必须采用二叉链表结构	（×）</p>
<p>9、二叉树的第i层上一定有 2^(i-1)个结点。	（×）</p>
<blockquote>
<p>二叉树的第i层上最多有 2^(i-1)个结点。</p>
</blockquote>
<p>10、健壮的算法不会因非法的输入数据而出现莫名其妙的状态。	（√）</p>
<blockquote>
<p>健壮的算法，当有非法输入的时候，程序会自动给出错误提示而不会出现莫名奇怪的状态</p>
</blockquote>
<h2 id="四-设计题">四、设计题</h2>
<p>1、</p>
<figure data-type="image" tabindex="5"><a href="https://imgtu.com/i/4R3mxs"><img src="https://z3.ax1x.com/2021/09/27/4R3mxs.png" alt="4R3mxs.png" loading="lazy"></a></figure>
<blockquote>
<p>参考：https://wenku.baidu.com/view/0cabf3ea81c758f5f61f677a.html</p>
</blockquote>
<p>2、将稀疏矩阵的三元组顺序表修改为 带行指针数组的二元组顺序表</p>
<h2 id="五-问答题-2">五、问答题</h2>
<p>1、已知二叉树的先序、中序序列，求其高度、叶子结点数，画出该二叉树和后续线索</p>
<p>2、已知广义表，求其长度、深度、表头、表尾，画出其链式存储结构的示意图</p>
<h2 id="六-算法填空题-2">六、算法填空题</h2>
<p>1、单链表的原地逆转</p>
<blockquote>
<p>参考：https://www.cnblogs.com/young-for-you/p/7286905.html</p>
<p>http://blog.sina.com.cn/s/blog_68c53ea90101bcl5.html</p>
</blockquote>
<p>2、在中序线索二叉树中插入左孩子</p>
<blockquote>
<p>参考：https://wenku.baidu.com/view/0b085eec58eef8c75fbfc77da26925c52dc5910d.html</p>
</blockquote>
<h2 id="七-算法设计题-2">七、算法设计题</h2>
<p>1、用不带头结点的单循环链表表示队列，完成入队、出队函数</p>
<blockquote>
<p>参考：https://blog.csdn.net/weixin_44790790/article/details/110297513</p>
</blockquote>
<h1 id="网课笔记">网课笔记</h1>
<h2 id="第一章">第一章</h2>
<p>只需挑循环中的一个基本操作分析它的执行次数与n的关系即可</p>
<p>如果有多层嵌套循环，只需关注最深层循环循环了几次</p>
<h2 id="第二章线性表">第二章	线性表</h2>
<p>具有相同数据类型的有限序列，每个数据元素所占空间一样大</p>
<p>表长n=0时，线性表是一个空表</p>
<p>ai是线性表中的第i个元素，i是位序	位序从1开始，数组下标从0开始	a1是表头元素，an是表尾元素</p>
<p>线性表分为顺序表（顺序存储）和链表（链式存储）</p>
<p>求一个数据元素的大小：sizeof(ElemType)</p>
<h3 id="顺序表的实现静态分配">顺序表的实现——静态分配</h3>
<p>静态数组：定义的最大长度不可改变（存储空间是静态的）</p>
<p>大小为：MaxSize * sizeof(ElemType)</p>
<h3 id="顺序表的实现动态分配">顺序表的实现——动态分配</h3>
<p>malloc函数返回一个指针，需要强制转型为你定义的数据元素类型指针</p>
<pre><code class="language-c++">ElemType *data;	//指示动态分配数组的指针
L.data = (ElemType *) malloc(sizeof(ElemType) * InitSize);	//申请一片连续的存储空间
</code></pre>
<p>顺序表的特点：</p>
<p>①随机访问</p>
<p>②存储密度高</p>
<p>③拓展容量不方便</p>
<p>④插入删除不方便，要移动大量元素</p>
<p>插入操作时间复杂度	最好情况：O(1)	最坏情况：O(n)	平均情况O(n)</p>
<p>删除操作时间复杂度	最好情况：O(1)	最坏情况：O(n)	平均情况O(n)</p>
<p>按位查找：获取第i个位置的元素的值	时间复杂度O(1)</p>
<p>按值查找：查找具有给定关键字值的元素	时间复杂度O(n)</p>
<p>注意：手写代码主要考察是否理解算法思想，不会严格要求代码完全可以运行</p>
<h4 id="单链表">单链表</h4>
<p>每个结点除了存放数据元素外，还要存储指向下一个结点的指针</p>
<pre><code class="language-c++">struct LNode * p (struct LNode *) malloc(sizeof(struct LNode));	//增加一个新结点
</code></pre>
<p>typedef  数据类型 别名;</p>
<p>用途：数据类型重命名</p>
<p>所以可以简洁代码：</p>
<pre><code class="language-c++">typedef struct LNode Lnode;
LNode * p = (LNode *) malloc(sizeof(LNode));	//增加一个新结点
</code></pre>
<p>会采用重命名的方式来定义类型</p>
<figure data-type="image" tabindex="6"><a href="https://imgtu.com/i/4R31aT"><img src="https://z3.ax1x.com/2021/09/27/4R31aT.png" alt="4R31aT.png" loading="lazy"></a></figure>
<figure data-type="image" tabindex="7"><a href="https://imgtu.com/i/4R3lZV"><img src="https://z3.ax1x.com/2021/09/27/4R3lZV.png" alt="4R3lZV.png" loading="lazy"></a></figure>
<p>不带头结点：头指针会存放实际数据	写代码会麻烦一点</p>
<p>带头结点的单链表：头结点不存储数据	方便一些</p>
<p>按位序插入（带头结点）：可以把头结点看作第0个结点</p>
<p>按位序插入（不带头结点）：i=1时要进行特殊处理</p>
<p>考试中两种情况都有可能考察，注意审题</p>
<p>按位序删除：只考虑带头结点</p>
<p>单链表的查找（只考虑带头结点）	这个函数可以用在别的函数内，找到指定结点</p>
<p>​	按位查找：返回第i个元素	O(n)</p>
<p>​	按值查找：找到数据域==e的结点	O(n)</p>
<p>单链表的建立：核心就是初始化操作、指定结点的后插操作</p>
<p>​	尾插法	设置一个表尾指针</p>
<p>​	头插法	可以用作链表的逆置	设置表头指针</p>
<p>双链表：可以逆向检索</p>
<p>​	双链表的初始化（带头结点）</p>
<p>​	双链表不可随机存取，查找只能通过遍历实现</p>
<p>循环链表</p>
<p>​	单链表	从一个结点出发只能找到后续的结点</p>
<p>​	循环单链表	从一个结点出发，可以找到其他任何结点</p>
<p>​	循环双链表	形成了两个闭环</p>
<p>静态链表</p>
<p>数组下标充当指针</p>
<p>​	分配一整片连续的内存空间</p>
<h2 id="第三章">第三章</h2>
<h3 id="栈">栈</h3>
<p>只允许在一段进行插入或删除的线性表</p>
<p>栈顶：允许插入、删除的一端</p>
<p>栈底：不允许的那一端</p>
<p>顺序栈的缺点：大小不可变</p>
<p>共享栈：两个栈共享同一片空间</p>
<h3 id="队列">队列</h3>
<p>只允许在一端进行插入，在另一端进行删除</p>
<p>队头：删除</p>
<p>队尾：插入</p>
<p>顺序队列</p>
<p>链式队列</p>
<p>双端队列</p>
<p>栈中合法的序列，双端队列中必定合法</p>
<p>​	输入受限的双端队列：4213 4231是非法的</p>
<p>​	输出受限的双端队列：4132 4231是非法的</p>
<p>括号匹配问题：利用栈的特性</p>
<p>​	遇到左括号入栈，遇到右括号出栈配对</p>
<h3 id="中缀表达式">中缀表达式</h3>
<p>运算符在两个操作数中间</p>
<p>​		中缀转后缀(手算)：左运算符优先原则</p>
<p>​		中缀转后缀(机算)：三种情况</p>
<p>​		中缀转前缀(手算)：右运算符优先原则</p>
<p>​		中缀的计算(机算)：中缀转后缀+后缀表达式求值	两个算法的结合</p>
<h3 id="后缀表达式">后缀表达式</h3>
<p>运算符在两个操作数后面</p>
<p>​		后缀的计算(机算)：栈实现</p>
<h3 id="前缀表达式">前缀表达式</h3>
<p>运算符在两个操作数前面</p>
<p>​		前缀的计算：栈实现</p>
<h3 id="栈的应用">栈的应用</h3>
<p>递归</p>
<p>缺点：</p>
<p>​	递归层数太多会导致栈溢出</p>
<p>​	包含很多重复计算</p>
<h3 id="队列的应用">队列的应用</h3>
<p>树的层次遍历</p>
<p>图的广度优先遍历</p>
<h3 id="矩阵的压缩存储">矩阵的压缩存储</h3>
<p>一维数组</p>
<p>二维数组</p>
<p>​	行优先存储</p>
<p>​	列优先存储</p>
<p>特殊矩阵</p>
<p>​	对称矩阵	只存储主对角线+下三角区</p>
<p>​						按行优先将个元素存入一维数组中</p>
<p>​	三角矩阵	上三角和下三角矩阵</p>
<p>​						将行优先原则将区域元素存入一维数组中，并在最后一个位置存储常数</p>
<p>​	三对角矩阵/带状矩阵</p>
<p>​	稀疏矩阵	非零元素远远少于矩阵元素</p>
<p>​						顺序存储——三元组&lt;行，列，值&gt;</p>
<p>​						链式存储——十字链表法</p>
<h2 id="第四章串">第四章	串</h2>
<p>子串	主串</p>
<p>空串	空格串</p>
<p>串是一种特殊的线性表	数据元素之间呈线性关系</p>
<p>串的比较：越靠前越小</p>
<h3 id="串的顺序存储">串的顺序存储</h3>
<p>静态数组实现(定长顺序存储)</p>
<p>动态数组实现(堆分配存储 malloc)</p>
<h3 id="串的链式存储">串的链式存储</h3>
<h4 id="模式匹配">模式匹配</h4>
<p>在主串中找到与模式串相同的子串</p>
<p>①	朴素模式匹配算法	O(nm)</p>
<p>​				通过遍历依次进行对比</p>
<p>②	KMP算法	O(n+m)</p>
<p>​				求next数组</p>
<p>③	KMP算法优化</p>
<p>​				求nextval数组（对next数组的优化）</p>
<p>​</p>
<h2 id="第五章树">第五章	树</h2>
<p>空树：结点数为0的树</p>
<p>非空树：有且仅由一个根结点</p>
<p>叶子结点：终端结点</p>
<p>树是一种递归定义的数据结构	每个结点都可以看作根结点</p>
<h3 id="树的属性">树的属性</h3>
<p>​		结点的层次(深度)——从上往下数</p>
<p>​		结点的高度——从下往上数</p>
<p>​		树的高度(深度)——总共多少层</p>
<p>​		结点的度——有几个孩子(分支)</p>
<p>​		树的度——各结点的度的最大值</p>
<h3 id="树的常考性质">树的常考性质</h3>
<p>​		① 结点数=总度数+1</p>
<p>​				因为根节点是没有父母结点</p>
<p>​		② 度为m的树、m叉树的区别</p>
<h3 id="二叉树">二叉树</h3>
<p>空二叉树——结点数n为0</p>
<p>二叉树有5种状态</p>
<p>几种特殊的二叉树</p>
<p>满二叉树：长满分支的二叉树</p>
<p>​		特点：只有最后一层有叶子结点</p>
<p>​					不存在度为1的结点	只有2或0</p>
<p>​					编号，左孩子为2i，右孩子为2i+1</p>
<p>完全二叉树：每个结点和满二叉树的编号一一对应</p>
<p>​		特点：只有最后两层可能有叶子结点</p>
<p>​					最多只有一个度为1的结点</p>
<p>二叉排序树</p>
<p>平衡二叉树</p>
<h3 id="二叉树的常考性质">二叉树的常考性质</h3>
<p>结点数：n</p>
<p>n0=n2+1</p>
<p>n=n0+n1+n2</p>
<p>n=n1+2n2+1</p>
<p>树的结点数=总度数+1</p>
<h3 id="二叉树的存储结构">二叉树的存储结构</h3>
<p>二叉树的顺序存储：按层序遍历存储在数组中</p>
<p>二叉树的链式存储：二叉链表</p>
<p>​		找父节点——只能从根结点开始遍历寻找</p>
<p>三叉链表——方便找父结点</p>
<h3 id="二叉树的遍历">二叉树的遍历</h3>
<p>先序遍历：根左右		前缀表达式</p>
<p>中序遍历：左根右		中缀表达式（要加括号）</p>
<p>后序遍历：左右根		后缀表达式</p>
<p>求二叉树的深度</p>
<p>层序遍历：一层一层遍历</p>
<p>借用一个辅助队列</p>
<h3 id="由遍历序列构造二叉树">由遍历序列构造二叉树</h3>
<p>一个遍历序列可能对应多种二叉树形态，不能唯一确定一棵二叉树</p>
<p>一定要有一个中序序列</p>
<p>先+中：先序第一个是根结点	那么在中序序列中，根结点左边的就全都是它的左子树	然后递归，在先序中第二个就是左子树的根结点，剩下同理；右子树也同理</p>
<p>后+中：后序中最后一个是根结点	接着在中序中找到根结点，左边是左子树，右边是右子树，再递归，同理，后序找根结点，中序通过根结点的左右划分子树</p>
<p>层+中：层序第一个是根结点，第二个可以是左子树的根结点，第三个可以是右子树的根结点。所以先找根结点，再划分左右子树，递归</p>
<p>重点：找到树的根结点，并根据中序序列划分左右子树，再找到左右子树的根结点</p>
<p>如果不要中序序列，前序、后序、层序两两组合不能唯一确定一棵二叉树</p>
<h3 id="线索二叉树">线索二叉树</h3>
<p>指向前驱、后继的指针称为“线索”</p>
<p>n个结点的二叉树有n+1个空链域，可以用来记录前驱、后继</p>
<p>tag==0	表示指针指向孩子</p>
<p>tag==1	表示指针是线索</p>
<p>中序线索二叉树	线索指向中序前驱、中序后继</p>
<p>先序线索二叉树	线索指向先序前驱、先序后继</p>
<p>后序线索二叉树	线索指向后序前驱、后序后继</p>
<p>线索化：一边遍历一边线索化</p>
<p>中序线索二叉树找中序前驱、后继</p>
<p>先序线索二叉树找先序前驱、后继</p>
<p>后序线索二叉树找后序前驱、后继</p>
<h3 id="二叉排序树">二叉排序树</h3>
<p>(又称二叉查找树)</p>
<h3 id="哈夫曼树">哈夫曼树</h3>
<p>结点的权：有某种数值</p>
<p>结点的带权路径长度：路径长度 × 权值</p>
<h3 id="哈夫曼编码">哈夫曼编码</h3>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[面向对象程序设计（期末复习）]]></title>
        <id>https://amadeus075.github.io/post/mian-xiang-dui-xiang-cheng-xu-she-ji-qi-mo-fu-xi/</id>
        <link href="https://amadeus075.github.io/post/mian-xiang-dui-xiang-cheng-xu-she-ji-qi-mo-fu-xi/">
        </link>
        <updated>2021-09-27T12:59:20.000Z</updated>
        <content type="html"><![CDATA[<h1 id="食用说明">食用说明</h1>
<p>历年卷中涉及到的书本页数，是以计算机学院 李青老师编写的C++书籍（蓝色的，忘记名字了，书也送给学弟了）为标准。</p>
<p>历年卷老师应该会在复习课之前发电子版。</p>
<p>其余复习资料可在我的Github仓库中找到，Github链接在博主的头像下方可以找到。</p>
<p>本文很大程度上参考了一位学长的博客，本人并不认识他，故仅附其博客地址：</p>
<blockquote>
<p>https://www.cnblogs.com/aoru45/p/9897269.html	C++ 历年试题解析（一）--判断题</p>
<p>https://www.cnblogs.com/aoru45/category/1335888.html	随笔分类：C++</p>
</blockquote>
<p>在当时的复习阶段靠学长的笔记学到了很多，非常感谢这位学长。</p>
<h1 id="课堂笔记">课堂笔记</h1>
<p>考试：<br>
浅赋值、深赋值<br>
浅拷贝、深拷贝</p>
<p>函数类模板里是否允许含有一个其他的类模板或函数模板<br>
（类模板里可以有新的类模板吗）</p>
<p>函数模板里是否允许有其他的函数定义<br>
（函数模板里可以定义新的函数吗）</p>
<p>数组和函数不能引用<br>
只有常量、变量有引用</p>
<p>模板里面可以含多个未知数据类型，我们是学了简单的一个未知类型</p>
<p>考题：<br>
1）涉及多个交换变量的函数(年年都考)<br>
2）两个字符串函数<br>
3）引用</p>
<p>考试总共有4大题<br>
1、2大题是送分的<br>
3、4考验编程能力</p>
<p>最后一大题，就算写个函数头也是有分的<br>
（向量、复数、矩阵）</p>
<p>4套卷子的第一部分一定要都对</p>
<h1 id="历年卷">历年卷</h1>
<h2 id="18届面向对象考卷">18届面向对象考卷</h2>
<h3 id="一-判断">一、判断</h3>
<p>1、</p>
<p>如果没有定义任何构造函数，则编译器会自动定义默认构造函数，其形式如 testClass() {};</p>
<p>可以看出，编译器自动提供的默认构造函数什么也没有。</p>
<p>如果程序猿没有定义任何构造函数，则编译器会自动定义默认构造函数，其形式如 testClass() {};  可以看出，编译器自动提供的默认构造函数是 啥也没有啊 ；</p>
<p>只要手动定义了构造函数，编译器就不会再提供默认构造函数了。</p>
<p>2、P244	this指针常量</p>
<p><strong>this指针的用处:</strong></p>
<p>一个对象的this指针并不是对象本身的一部分，不会影响sizeof(对象)的结果。</p>
<p>this作用域是在类内部，当在类的非静态成员函数中访问类的非静态成员的时候，编译器会自动将对象本身的地址作为一个隐含参数传递给函数。也就是说，即使你没有写上this指针，编译器在编译的时候也是加上this的，它作为非静态成员函数的隐含形参，对各成员的访问均通过this进行。例如，调用date.SetMonth(9) &lt;===&gt; SetMonth(&amp;date, 9)，this帮助完成了这一转换 .</p>
<p>在成员函数内部，我们可以直接使用调用该函数的对象的成员，而无需通过成员访问运算符来做到这一点，因为this所指的正是这个对象。任何对类成员的直接访问都被看成this的隐式使用。</p>
<p><strong>this的目的总是指向这个对象，所以this是一个常量指针，我们不允许改变this中保存的地址</strong></p>
<p>①this指针的特性：<br>
a.)this指针的类型：类类型 *const;<br>
b.)this指针并不是对象的一部分，不会影响对象的大小；<br>
c.)this指针是非静态成员函数的第一个隐含指针形参，是编译器自己处理的，我们不能在成员函数的形参中添加this指针的参数定义，也不能在调用时显示传递对象的地址给this指针;</p>
<p>3、P245	常量成员函数</p>
<p>​		常量成员函数是类的成员函数，这种函数的隐含形式参数为指向本对象的常量指针常量(const 类名* const this) ，故在函数体内只能读取但不能修改本对象的任何属性。</p>
<p>4、P263、264	拷贝构造函数</p>
<p>​		局部自动对象（包括值传递的形参对象）在其所在函数每一次调用时创建，函数返回后析构。</p>
<p>5、</p>
<p>6、P340	派生类对基类的兼容性</p>
<p>​		派生类的对象可以初始化（拷贝构造）基类的对象、初始化基类的引用，可以赋值给基类的对象。派生类对象的地址可以初始化基类的指针变量，可以赋值给基类的指针变量。这种特性成为派生类对象对基类对象的初始化及赋值兼容性。</p>
<p>7、P338	派生类的构造与析构</p>
<p>​		基类的私有成员在派生类中是存在的，但是被隔离起来，不能直接访问。</p>
<p>8、P348	抽象类</p>
<p>​		不能创建抽象类的对象；可以定义抽象类的指针变量指向由其派生的具体类的对象；可以声明抽象类的引用，声明引用时必须用其派生的具体类的对象进行初始化。</p>
<p>9、P309	重载运算符</p>
<p>​		C++不允许用户自己定义新的运算符，只能对已有的部分运算符进行重载；不允许改变运算符操作数的个数（自然不允许使用带默认值的参数）；不能改变运算符的运算优先级；不能改变运算符的运算结合方向。</p>
<p>10、P309	重载运算符</p>
<p>​		C++不允许用户自己定义新的运算符，只能对已有的部分运算符进行重载；不允许改变运算符操作数的个数（自然不允许使用带默认值的参数）；不能改变运算符的运算优先级；不能改变运算符的运算结合方向。</p>
<h3 id="二-填空">二、填空</h3>
<p>函数模板的格式P175</p>
<h3 id="三-阅读程序写出结果及简答题">三、阅读程序写出结果及简答题</h3>
<p>注意：对象构造与析构的顺序</p>
<h3 id="四-完成类的设计">四、完成类的设计</h3>
<h2 id="17届面向对象考卷直招">17届面向对象考卷(直招)</h2>
<h3 id="一-判断-2">一、判断</h3>
<p>1、P244	this指针常量</p>
<p>​		C++编译器为所有非静态成员函数添加了一个隐含的形式参数，其数据类型为指针常量，参数名为C++保留字this，意味着this的指向被锁定不能更改。</p>
<p>2、解释：p能再使用，delete释放的是p指向内存的空间，不过指向有点问题。所以delete之后还是让p指向NULL吧，这也是我们经常应当做的。</p>
<p>3、P251,252	类模板和模板类</p>
<p>​		编译系统并不编译类模板，只有遇到全部确定了的待定数据类型后，由编译系统先自动生成一个实际的类——成为模板类，然后再对该模板类进行编译。</p>
<p>4、P299	友元类</p>
<p>​		可以声明一个类是另一个类的友元，成为友元类。</p>
<p>5、P290	静态成员函数</p>
<p>​		当有具体对象存在时可以采用对象访问成员的方式访问类的静态数据成员（当然还取决于该静态数据成员的访问控制属性）。</p>
<p>​		对象名.静态数据成员名</p>
<p>​		更一般的方法是只用类名而不用对象名。</p>
<p>​		类名::静态数据成员名</p>
<p>6、P309	重载运算符</p>
<p>​		C++不允许用户自己定义新的运算符，只能对已有的部分运算符进行重载；不允许改变运算符操作数的个数（自然不允许使用带默认值的参数）；不能改变运算符的运算优先级；不能改变运算符的运算结合方向。</p>
<p>7、P163	函数调用</p>
<p>​		函数形式参数的生命期存在于函数被调用时，在调用该函数时产生，用实际参数对其进行初始化，函数返回时销毁形式参数。</p>
<p>8、P163	函数调用</p>
<p>9、P338	派生类对象的构造</p>
<p>​		当派生类对象生成的时候会调用构造函数，首先调用基类的构造函数生成基类部分，然后调用自己的构造函数，析构的时候顺序正好相反，先析构自身的然后析构释放派生类的</p>
<p>10、P348	抽象类</p>
<p>​		至少含有一个纯虚函数的类称为抽象类。</p>
<p>​		不能创建抽象类的对象；可以定义抽象类的指针变量指向由其派生的具体类的对象；可以声明抽象类的引用，声明引用时必须用其派生的具体类的对象进行初始化。</p>
<h3 id="二-填空-2">二、填空</h3>
<pre><code>using namespace std;
</code></pre>
<p>注意看 上下类似的代码，有没有引用 <strong>&amp;</strong></p>
<p>运算符重载注意是友元函数，开头加 <strong>friend</strong></p>
<h3 id="三-阅读程序写出结果及简答题-2">三、阅读程序写出结果及简答题</h3>
<h3 id="四-完成类的设计-2">四、完成类的设计</h3>
<h2 id="17届面向对象考卷">17届面向对象考卷</h2>
<h3 id="一-判断-3">一、判断</h3>
<p>1、P345	重载运算符的多态性</p>
<p>2、解释：试了一下，p还真能再使用，所以不要理解错了，delete释放的是p指向内存的空间，他自己还活着，不过指向有点问题，所以delete之后还是让p指向NULL吧，这也是我们经常应当做的。</p>
<p>3、sizeof 运算符：以字节为单位返回运算对象的大小（1字节定义为char类型占用的空间大小），若运算对象是类型（如，float），则必须用圆括号将其括起来。</p>
<p>4、P275	冒号语法</p>
<p>5、P252	模板类的编译</p>
<p>6、P289	静态数据成员</p>
<p>7、P316	重载运算符  后++</p>
<p>8、P335	继承</p>
<p>9、P245	两个const的作用</p>
<p><strong>常量指针</strong>：指向常量的指针，例如const int *p = &amp;a,可以改变p的指向，但是指向的必须是常量。</p>
<p><strong>指针常量</strong>：就是常指针，例如int * const p = &amp; a ，可以修改p指向的变量的值，但是p的指向改不了。</p>
<p>10、</p>
<p><strong>首先先给出几个概念：</strong></p>
<p><strong>1）类对象在创建时会调用构造函数，在释放是会调用析构函数；</strong></p>
<p><strong>2）函数中的局部变量在函数返回后，会由于弹栈从而内存被释放；</strong></p>
<p><strong>3）如果函数参数是采用值传递的方式传入类对象，则由于值传递的性质，先调用类复制构造函数产生一个临时对象，然后在函数返回后会调用类析构函数将该临时对象内存释放；</strong></p>
<p><strong>所以在对类对象进行参数传递的过程中，采用引用传递是一个正确的方式。</strong></p>
<p>其实这个坑也说明了一个问题，<strong>复制构造函数为什么是采用引用传递的形式，而不是采用值传递</strong>。假如采用值传递的方式，会导致什么样的后果？（会无限递归调用复制构造函数，当然实际过程中代码是不会通过编译的）</p>
<h3 id="二-填空-3">二、填空</h3>
<p>注意参数的类型</p>
<p>注意：<code>char *p = new char [strlen(x) +1];</code></p>
<h3 id="三-阅读程序写出结果及简答题-3">三、阅读程序写出结果及简答题</h3>
<h3 id="四-完成类的设计-3">四、完成类的设计</h3>
<h2 id="16届面向对象考卷">16届面向对象考卷</h2>
<h3 id="一-判断-4">一、判断</h3>
<p>1、P241	成员的访问控制</p>
<p>2、P258	构造函数</p>
<p>3、P264	拷贝构造函数</p>
<p>只有在定义初始化时调用构造函数<br>
构造函数不能被直接调用,必须在创建对象时才会自动调用</p>
<p>4、P243 	对象的基本空间</p>
<p>​	  P268 	对象的资源空间</p>
<p>5、P243	对象的基本空间</p>
<p>6、P289-290	静态数据成员</p>
<p>7、</p>
<p>8、P244  	this指针常量</p>
<p>9、P332  	继承</p>
<p>10、P309	重载运算符</p>
<h3 id="二-填空-4">二、填空</h3>
<h3 id="三-阅读程序写出结果及简答题-4">三、阅读程序写出结果及简答题</h3>
<h3 id="四-完成类的设计-4">四、完成类的设计</h3>
<h1 id="自己搜集的题目">自己搜集的题目</h1>
<p>1.C++中的struct和class有什么区别？<br>
【答案】从语法上讲，class和struct做类型定义时只有两点区别：<br>
(1)默认<strong>继承权限</strong>。如果不明确指定，来自class的继承按照private继承处理，来自struct的继承按照public继承处理；<br>
(2)成员的默认<strong>访问权限</strong>。class的成员默认是private权限，struct默认是public权限。 除了这两点，class和struct基本就是一个东西。语法上没有任何其它区别。<br>
（敲黑板：继承和访问权限不同，struct为public，class为private）</p>
<p>2.“引用”与指针的区别是什么？<br>
【答案】指针通过某个指针变量指向一个对象后，对它所指向的变量间接操作。程序中使用指针，程序的可读性差；而引用本身就是目标变量的别名，对引用的操作就是对目标变量的操作。</p>
<ol start="3">
<li></li>
</ol>
<p><code>class A {</code><br>
<code>virtual void func1()；</code><br>
<code>void func2();</code><br>
<code>} ；</code><br>
<code>class B: class A</code><br>
<code>{</code><br>
<code>void func1(){</code><br>
<code>cout &lt; &lt; “func1 in class B” &lt; &lt; endl;}</code><br>
<code>virtual void func2(){cout &lt; &lt; “fun2 in class B” &lt; &lt; endl;}</code><br>
<code>}</code><br>
A. A中的func1和B中的func2都是虚函数.<br>
B. A中的func1和B中的func2都不是虚函数.<br>
C. A中的func2是虚函数，B中的func1不是虚函数.<br>
D. A中的func2不是虚函数，B中的func1是虚函数.<br>
【答案】A</p>
<p>4.某文件中定义的静态全局变量(或称静态外部变量)其作用域是 ()?<br>
A.只限某个函数 B.本文件 C.跨文件 D.不限制作用域<br>
【答案】B。静态全局变量则限制了其作用域， 即只在定义该变量的源文件内有效， 在同一源程序的其它源文件中不能使用它。由于静态全局变量的作用域局限于一个源文件内，只能为该源文件内的函数公用， 因此可以避免在其它源文件中引起错误。</p>
<p>5.C++函数中值的传递方式有哪几种?<br>
【答案】C++函数的三种传递方式为：值传递、指针传递和引用传递。</p>
<p>6.引用与指针有什么区别？<br>
【答案】</p>
<ol>
<li>引用创建时必须同时被初始化，指针可以在任何时候初始化。</li>
<li>引用初始化后不能改变引用关系，指针能随时改变所指的对象。</li>
<li>不存在指向空值的引用，但是存在指向空值的指针。</li>
</ol>
<p>7.C++中virtual的含义分别是什么？<br>
【答案】<br>
在基类成员函数的声明前加上virtual关键字，意味着将该成员函数声明为虚函数。<br>
虚函数的特点：如果希望派生类能够重新定义基类的方法，则在基类中将该方法定义为虚方法，这样可以启用动态联编。</p>
<p>8.有了 malloc/free 为什么还要 new/delete？<br>
【答案】<br>
malloc 与 free 是 C++/C 语言的标准库函数，new/delete 是 C++的运算符。它们都可用于申请动态内存和释放内存。 对于非内部数据类型的对象而言，光用 maloc/free 无法满足动态对象的要求。对象在创建的同时要自动执行构造函数，对象在消亡之前要自动执行析构函数。由于malloc/free 是库函数而不是运算符，不在编译器控制权限之内，不能够把执行构造函数和析构函数的任务强加malloc/free。 因此 C++语言需要一个能完成动态内存分配和初始化工作的运算符 new，以及一个能完成清理与释放内存工作的运算符 delete。注意 new/delete 不是库函数。</p>
<p>9.const 符号常量：<br>
(1)const char *p<br>
(2)char const *p<br>
(3)char * const p<br>
说明上面三种描述的区别；</p>
<p>(1)p是一个指向const char的指针，p是可以改变指向的，但是p指向的值是不能改变的;</p>
<p>(2)p指向的恰好是一个指向const的char的普通指针；</p>
<p>(3)p是一个指针，这个指针是指向char的const指针。(1)和(2)的定义是一样的。</p>
<p>10.多态类中的虚函数表是Compile-Time，还是Run-Time时建立的?<br>
【答案】虚拟函数表是在编译期就建立了,各个虚拟函数这时被组织成了一个虚拟函数的入口地址的数组.而对象的隐藏成员–虚拟函数表指针是在运行期–也就是构造函数被调用时进行初始化的,这是实现多态的关键。</p>
<p>11.若数组名作实参而指针变量作形参，函数调用实参传给形参的是()<br>
A.数组的长度<br>
B.数组第一个元素的值<br>
C.数组所有元素的值<br>
D.数组第一个元素的地址<br>
【答案】D</p>
<p>12.变量的指针含意是指变量的 ()<br>
A.值<br>
B.地址<br>
C.存储<br>
D.名字<br>
【答案】B</p>
<p>13.内存的分配方式有几种?<br>
【答案】<br>
（1）从静态存储区域分配。内存在程序编译的时候就已经分配好，这块内存在程序的整个运行期间都存在。例如全局变量。<br>
（2）在栈上创建。在执行函数时，函数内局部变量的存储单元都可以在栈上创建，函数执行结束时这些存储单元自动被释放。栈内存分配运算内置于处理器的指令集中，效率很高，但是分配的内存容量有限。<br>
（3）从堆上分配，亦称动态内存分配。程序在运行的时候用malloc或new申请任意多少的内存，程序员自己负责在何时用free或delete释放内存。动态内存的生存期由我们决定，使用非常灵活，但问题也最多。</p>
<p>14.全局变量和局部变量有什么区别？是怎么实现的？操作系统和编译器是怎么知道的？<br>
【答案】</p>
<p>生命周期不同：全局变量随主程序创建和创建，随主程序销毁而销毁；局部变量在局部函数内部，甚至局部循环体等内部存在，退出就不存在； 内存中分配在全局数据区。</p>
<p>使用方式不同：通过声明后全局变量程序的各个部分都可以用到；局部变量只能在局部使用，分配在栈区。 操作系统和编译器通过内存分配的位置来知道的，全局变量分配在全局数据段并且在程序开始运行的时候被加载。局部变量则分配在堆栈里面 。</p>
<p>15.为什么数组名作为参数，会改变数组的内容，而其它类型如int却不会改变变量的值？<br>
【答案】当数组名作为参数时，传递的实际上是地址。而其他类型如int作为参数时，由于函数参数值实质上是实参的一份拷贝，被调函数内部对形参的改变并不影响实参的值。</p>
<p>16.const关键字？有哪些作用<br>
【答案】<br>
const关键字至少有下列n个作用：<br>
（1）欲阻止一个变量被改变，可以使用const关键字。在定义该const变量时，通常需要对它进行初始化，因为以后就没有机会再去改变它了；<br>
（2）对指针来说，可以指定指针本身为const，也可以指定指针所指的数据为const，或二者同时指定为const；<br>
（3）在一个函数声明中，const可以修饰形参，表明它是一个输入参数，在函数内部不能改变其值；<br>
（4）对于类的成员函数，若指定其为const类型，则表明其是一个常函数，不能修改类的成员变量；<br>
（5）对于类的成员函数，有时候必须指定其返回值为const类型，以使得其返回值不为“左值”。</p>
<p>17.是不是一个父类写了一个virtual 函数，如果子类覆盖它的函数不加virtual ,也能实现多态?<br>
【答案】virtual修饰符会被隐形继承的。virtual可加可不加。子类的空间里有父类的所有变量(static除外)。同一个函数只存在一个实体(inline除外)。子类覆盖它的函数不加virtual ,也能实现多态。在子类的空间里，有父类的私有变量。私有变量不能直接访问。</p>
<p>18.面向对象的三个基本特征，并简单叙述之？<br>
【答案】<br>
（1）封装：将客观事物抽象成类，每个类对自身的数据和方法实行protection(private,protected,public)<br>
（2）继承：广义的继承有三种实现形式：实现继承（指使用基类的属性和方法而无需额外编码的能力）、可视继承（子窗体使用父窗体的外观和实现代码）、接口继承（仅使用属性和方法，实现滞后到子类实现）。前两种（类继承）和后一种（对象组合=&gt;接口继承以及纯虚函数）构成了功能复用的两种方式。<br>
（3）多态：是将父对象设置成为和一个或更多的与他的子对象相等的技术，赋值之后，父对象就可以根据当前赋值给它的子对象的特性以不同的方式运作。简单的说，就是一句话：允许将子类类型的指针赋值给父类类型的指针。</p>
<p>19.重载（overload)、重写(override，有的书也叫做“覆盖”）、重定义（redefinition）的区别？<br>
【答案】</p>
<table>
<thead>
<tr>
<th>名称</th>
<th>名字空间</th>
<th>区别</th>
</tr>
</thead>
<tbody>
<tr>
<td>重载</td>
<td>同一名字子空间</td>
<td>是指允许存在多个同名函数，而这些函数的参数表不同。</td>
</tr>
<tr>
<td>重定义/隐藏</td>
<td>不同名字子空间</td>
<td>用于继承，派生类与基类的函数同名，屏蔽基类的函数</td>
</tr>
<tr>
<td>重写/覆盖</td>
<td>不同名字子空间</td>
<td>用于继承，子类重新定义父类虚函数的方法</td>
</tr>
</tbody>
</table>
<p>20.多态的作用？<br>
【答案】主要是两个：（1）隐藏实现细节，使得代码能够模块化；扩展代码模块，实现代码重用；（2）接口重用：为了类在继承和派生的时候，保证使用家族中任一类的实例的某一属性时的正确调用。</p>
<p>21.当一个类A 中没有声命任何成员变量与成员函数,这时sizeof(A)的值是多少，如果不是零，请解释一下编译器为什么没有让它为零。<br>
【答案】sizeof(A)= 1。编译器不允许一个类的大小为0，会为它分配1字节的内存。若不这样做，那2个类A的实例在内存中将会无法区分。 一个空类对象的大小是1byte。这是被编译器安插进去的一个字节，这样就使得这个空类的两个实例得以在内存中配置独一无二的地址。</p>
<p>22.如果ClassA中定义并实现虚函数int func(void)，ClassB中也实现该函数，那么上述变量a-&gt;func()将调用哪个类里面的函数？如果int func(void)不是虚函数，情况又如何？为什么？<br>
【答案】第一问调用的是B的。第二问调用A的。虚函数的一个典型应用，虚函数只能借助于指针或者引用来达到多态的效果。</p>
<p>23.请讲一讲析构函数和虚函数的用法和作用？<br>
【答案】析构函数是特殊的类成员函数，它没有返回类型，没有参数，不能随意调用，也没有重载，只有在类对象的生命期结束的时候，由系统自动调用，有释放内存空间的作用。虚函数是C++多态的一种表现, 使用虚函数，我们可以灵活的进行动态绑定，当然是以一定的开销为代价。</p>
<p>24.C++程序下列说法正确的有:<br>
A、对调用的虚函数和模板类都进行迟后编译.<br>
B、基类与子类中函数如果要构成虚函数,除了要求在基 类中用virtual 声名,而且必须名字相同且参数类型相同返回类型相同。<br>
C、重载的类成员函数都必须要:或者返回类型不同,或者参数数目不同,或者参数序列的类型不同.<br>
D、静态成员函数和内联函数不能是虚函数,友员函数和构造函数也不能是虚函数,但是析构函数可以是虚函数.<br>
【标准答案】A</p>
<p>25.在C++中有没有纯虚构造函数？<br>
【答案】构造函数不能是虚的。只能有虚的析构函数。</p>
<p>26.在c++的一个类中声明一个static成员变量的用处：<br>
【答案】在C++类的成员变量被声明为static（称为静态成员变量），意味着它为该类的所有实例所共享，也就是说当某个类的实例修改了该静态成员变量，也就是说不管创建多少对象，static修饰的变量只占有一块内存。其修改值为该类的其它所有实例所见；而类的静态成员函数也只能访问静态成员（变量或函数）。static是加了访问控制的全局变量，不被继承。</p>
<p>27.函数模板与类模板有什么区别？<br>
【答案】函数模板的实例化是由编译程序在处理函数调用时自动完成的，而类模板的实例化必须由程序员在程序中显式地指定</p>
<p>28、所有的运算符都能重载吗？<br>
【答案】不能被重载的运算符<br>
在 C++运算符集合中，有一些运算符是不允许被重载的。这种限制是出于安全方面的考虑，可防止错误和混乱。<br>
（1）不能改变 C++内部数据类型（如 int,float 等）的运算符。<br>
（2）不能重载‘.’，因为‘.’在类中对任何成员都有意义，已经成为标准用法。<br>
（3）不能重载目前 C++运算符集合中没有的符号，如#,@,$等。原因有两点，一是难以理解，二是难以确定优先级。<br>
（4）对已经存在的运算符进行重载时，不能改变优先级规则，否则将引起混乱。</p>
<p>29.基类的析构函数不是虚函数，会带来什么问题？<br>
【答案】派生类的析构函数用不上，会造成资源的泄漏。</p>
<p>30.写一个能做左值的函数(方法有很多)。如：<br>
<code>max(x, y) += 2874 + 55;</code><br>
<code>drwline(x, y)++;</code><br>
【答案】</p>
<pre><code class="language-cpp">int &amp;max(int &amp; x, int &amp; y)
{
     return x &gt; y? x : y;
}
int x = 55, y = 77;
max(x, y) += 12 + 11;                        // 此时 y = 100;
cout &lt;&lt; &quot;x = &quot;x &lt;&lt; &quot;;y = &quot;&lt;&lt; y &lt;&lt; endl;      // 输出 x = 55; y = 100;
</code></pre>
<p>31.以下三条输出语句分别输出什么？<br>
<code>char str1[] = “abc”;</code><br>
<code>char str2[] = “abc”;</code><br>
<code>const char str3[] = “abc”;</code><br>
<code>const char str4[] = “abc”;</code><br>
<code>const char* str5 = “abc”;</code><br>
<code>const char* str6 = “abc”;</code><br>
<code>cout &lt;&lt; boolalpha &lt;&lt; ( str1 == str2 ) &lt;&lt; endl; // 输出什么？</code><br>
<code>cout &lt;&lt; boolalpha &lt;&lt; ( str3 == str4 ) &lt;&lt; endl; // 输出什么？</code><br>
<code>cout &lt;&lt; boolalpha &lt;&lt; ( str5 == str6 ) &lt;&lt; endl; // 输出什么？</code><br>
【答案】分别输出false,false,true。str1和str2都是字符数组，每个都有其自己的存储区，它们的值则是各存储区首地址，不等；str3和str4同上，只是按const语义，它们所指向的数据区不能修改。str5和str6并非数组而是字符指针，并不分配存储区，其后的“abc”以常量形式存于静态数据区，而它们自己仅是指向该区首地址的指针，相等。</p>
<h1 id="重要知识点">重要知识点</h1>
<p>后记：当时因为懒只写了一点点，重要的知识不止这么点</p>
<h2 id="1常量指针和指针常量">1.常量指针和指针常量</h2>
<p><strong>常量指针</strong>：指向常量的指针，例如const int *p = &amp;a,可以改变p的指向，但是指向的必须是常量。</p>
<p><strong>指针常量</strong>：就是常指针，例如int * const p = &amp; a ，可以修改p指向的变量的值，但是p的指向改不了。</p>
<h2 id="2函数传参问题">2.函数传参问题</h2>
<p>void f(const int &amp;a) 可以传入表达式参数</p>
<p>void f(int &amp;a) 不能传入表达式参数</p>
<p>原因：表达式其实是一个函数，例如a+b返回的其实是个临时变量的值，传值过来就被视为常量，而c++规定引用传参不允许绑定常量，也就是说，引用必须引用的是一个变量，由于传来的是常量，所以不能引用。而前者是常引用，也就意味着可以引用常量，从而解决了表达式传参的问题。</p>
<h2 id="3只传部分参数返回结构体引发的生命周期问题">3.只传部分参数返回结构体引发的生命周期问题</h2>
<p><code>struct AA</code></p>
<p><code>{</code></p>
<p>​	  <code>int x;</code></p>
<p><code>}</code></p>
<p><code>AA *f(int a,int b,int c)</code></p>
<p><code>{</code></p>
<pre><code>`AA aa;`

 `AA * p = &amp;aa;`

 `aa.x = a + b +c;`

 `return p`
</code></pre>
<p><code>}</code></p>
<p>这个函数显然写的有问题，因为aa的生命周期在函数内，在函数外就没用了，因为返回指向aa的指针是没有意义的。</p>
<p>解决方法：</p>
<p>①动态生成结构体</p>
<p><code>A *p = new A();</code></p>
<p>这种new出来的结构体生命周期是在你delete之前一直存在的，所以符合要求，不过要记得在main函数执行完了或者在其他地方释放掉内存。</p>
<p>②局部静态结构体</p>
<p><code>static AA aa;</code></p>
<p>在AA aa 前加上static让他成为静态变量，这样生命周期就长于这个函数了，不过这样破坏了C++的局部可见性，不是很推荐。</p>
<p>然后其他的引用等方法没必要写了，太常规。</p>
<h2 id="4template知识点">4.Template知识点</h2>
<p>template想要处理多个数据类型不同的变量的时候，可以这么定义：</p>
<p><code>Template &lt;typename T,typename,P&gt;</code></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[本站的搭建原因]]></title>
        <id>https://amadeus075.github.io/post/ben-zhan-de-da-jian-yuan-yin/</id>
        <link href="https://amadeus075.github.io/post/ben-zhan-de-da-jian-yuan-yin/">
        </link>
        <updated>2021-09-27T05:24:34.000Z</updated>
        <content type="html"><![CDATA[<h1 id="近况">近况</h1>
<p>​	最近接了一个必须使用Rust的项目，涉及计算机视觉、计算机网络等方向。</p>
<p>​	由于学校神奇的课程安排，现在才刚刚开始学习计网，有很多知识点并不太了解；而且也根本没有接触过Rust语言，对着Rust程序设计语言硬啃没有什么正向反馈，写不出什么有意思的小项目，整个人很焦虑，所以想尝试做出一点新东西来跳出焦虑情绪。</p>
<p>​	最初想搭建博客的想法已经有大半年的时间了，那个时候别人推荐了Hugo，当时还想着了解一下Golang，没了解多少又要开始学Rust，还是希望自己能在某一语言或者领域深入一点，不要什么都只懂一点点。</p>
<p>​	最后感谢不是很懂但还是会仔细看我写的东西的笨蛋。</p>
<h1 id="博客内容">博客内容</h1>
<p>主要是发布一些学习笔记，现在主要是Python，以后可能有Rust，前提是自己学会。</p>
<p>还有就是大学课程的复习笔记，其实都发在了Github上，包括复习资料，但是小朋友们好像都不怎么会用，其中也有Github网络连接不稳定等因素，所以会将以前写的东西在这里重新发一遍。</p>
<h1 id="其他">其他</h1>
<p>顺便也把近期的学习情况和学习目标列一下吧，不然感觉没有什么监督，总是会摸鱼。</p>
<h2 id="阅读书目">阅读书目</h2>
<ul class="contains-task-list">
<li class="task-list-item">
<p><input class="task-list-item-checkbox" disabled="" type="checkbox" id="task-item-3536302"><label class="task-list-item-label" for="task-item-3536302"> 图解TCP/IP</label></p>
<p>​	在学校课程开始前阅读了一小半，后面因为忙别的事情搁置了，希望自己能看完</p>
</li>
<li class="task-list-item">
<p><input class="task-list-item-checkbox" disabled="" type="checkbox" id="task-item-2372702"><label class="task-list-item-label" for="task-item-2372702"> 计算机网络-自顶向下方法</label></p>
<p>​	打算读完图解TCP之后读</p>
</li>
<li class="task-list-item">
<p><input class="task-list-item-checkbox" checked="" disabled="" type="checkbox" id="task-item-7027449"><label class="task-list-item-label" for="task-item-7027449"> 鸟哥的Linux私房菜</label></p>
<p>​	也是在学校的OS课之前读的，进度50%吧，后面的章节感觉暂时不太用得上（？）</p>
</li>
<li class="task-list-item">
<p><input class="task-list-item-checkbox" disabled="" type="checkbox" id="task-item-741168"><label class="task-list-item-label" for="task-item-741168"> Rust程序设计语言</label></p>
<p>​	13/20章。还需要时间去消化和实际操作</p>
</li>
<li class="task-list-item">
<p><input class="task-list-item-checkbox" disabled="" type="checkbox" id="task-item-7283196"><label class="task-list-item-label" for="task-item-7283196"> 算法导论</label></p>
<p>​	发现老师是根据这本书而非课本进行讲课、布置题目的</p>
</li>
<li class="task-list-item">
<p><input class="task-list-item-checkbox" checked="" disabled="" type="checkbox" id="task-item-2668980"><label class="task-list-item-label" for="task-item-2668980"> 动手深度学习+PyTorch</label></p>
<p>​	暑假实习时扫过一遍</p>
</li>
<li class="task-list-item">
<p><input class="task-list-item-checkbox" checked="" disabled="" type="checkbox" id="task-item-5665910"><label class="task-list-item-label" for="task-item-5665910"> Linux就该这么学</label></p>
<p>​	不如鸟哥</p>
</li>
<li class="task-list-item">
<p><input class="task-list-item-checkbox" checked="" disabled="" type="checkbox" id="task-item-1227802"><label class="task-list-item-label" for="task-item-1227802"> 利用Python进行数据分析</label></p>
<p>​	暑假实习时扫过一遍</p>
</li>
<li class="task-list-item">
<p><input class="task-list-item-checkbox" checked="" disabled="" type="checkbox" id="task-item-3680710"><label class="task-list-item-label" for="task-item-3680710"> Python程序设计</label></p>
<p>​	为了恶补Python读的</p>
</li>
</ul>
<p><s>- [ ] Python编程快速上手—让繁琐工作自动化</s></p>
<p>​	    感觉排版和代码格式很不喜欢，放弃读了</p>
<ul class="contains-task-list">
<li class="task-list-item">
<p><input class="task-list-item-checkbox" disabled="" type="checkbox" id="task-item-8820492"><label class="task-list-item-label" for="task-item-8820492"> 数字图像处理</label></p>
<p>​	好多数学公式</p>
</li>
<li class="task-list-item">
<p><input class="task-list-item-checkbox" disabled="" type="checkbox" id="task-item-1425311"><label class="task-list-item-label" for="task-item-1425311"> python计算机视觉</label></p>
<p>​	课内实验大概要用到</p>
</li>
</ul>
<p>以上除了数字图像处理（第四版）入手了彩色纸质书外，其他都是电子书</p>
<p>有空闲时间了会把这些书（带书签）的获取方式贴在博客上，大概</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[使用说明（置顶）]]></title>
        <id>https://amadeus075.github.io/post/about/</id>
        <link href="https://amadeus075.github.io/post/about/">
        </link>
        <updated>2021-09-26T16:25:13.000Z</updated>
        <content type="html"><![CDATA[<blockquote>
<p>欢迎来到朝承恩的猫爬架 🤝</p>
</blockquote>
<h2 id="关于本站">🏠 关于本站</h2>
<p>本站主要用于满足表达欲、发布学习笔记，以及记录一些奇奇怪怪的想法。<br>
因为已有的社交平台已经沦落为沙雕猫图发布区，在那里并不想打破不发文字和自我想法的习惯。</p>
<h2 id="博主是谁">👨‍💻 博主是谁</h2>
<p>上海不知名高校    计算机科学与技术   学院及专业内底层人士   大学三年级学生<br>
朝承恩不是本名，本人不姓朝<br>
补充：朝是朝暮的朝，念zhao喔</p>
<h2 id="兴趣爱好">⛹ 兴趣爱好</h2>
<p>摸猫猫<br>
看笨蛋</p>
<h2 id="联系我呀">📬 联系我呀</h2>
<p>QQ：1073054587<br>
Github：Amadeus075<br>
Mail：Amadeus075@outlook.com</p>
]]></content>
    </entry>
</feed>